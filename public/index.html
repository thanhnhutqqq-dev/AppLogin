<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Auto Login Dashboard</title>
  <style>
    html,
    body {
      height: 100%;
      min-height: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.85), rgba(59, 130, 246, 0.85), #ffffff);
      background-attachment: fixed;
      background-size: cover;
      background-repeat: no-repeat;
      font-family: 'Inter', sans-serif;
    }

    body.fixed {
      position: fixed;
      width: 100%;
    }

    #app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    :root {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #0f172a;
      background-color: #eef2ff;
      --glass-bg: rgba(255, 255, 255, 0.3);
      --glass-border: rgba(255, 255, 255, 0.55);
      --glass-shadow: 0 24px 54px -32px rgba(15, 23, 42, 0.7);
      --transition-slow: 0.4s ease;
      --app-vh: 100vh;
    }

    * {
      box-sizing: border-box;
    }

    *::before,
    *::after {
      box-sizing: inherit;
    }

    html {
      min-height: 100%;
      background: radial-gradient(circle at 0% 0%, rgba(255, 255, 255, 0.92) 0%, rgba(239, 246, 255, 0.95) 45%, rgba(224, 247, 255, 0.9) 100%);
    }

    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      min-height: var(--app-vh);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: clamp(1.5rem, 4vw, 3.5rem);
      background: radial-gradient(circle at 0% 0%, rgba(255, 255, 255, 0.92) 0%, rgba(239, 246, 255, 0.95) 45%, rgba(224, 247, 255, 0.9) 100%);
      color: inherit;
      position: relative;
      overflow-x: hidden;
    }

    body::before,
    body::after {
      content: '';
      position: fixed;
      z-index: -1;
      width: max(35vw, 320px);
      height: max(35vw, 320px);
      filter: blur(120px);
      opacity: 0.65;
      pointer-events: none;
      transform: translate(-50%, -50%);
    }

    body::before {
      top: 12%;
      left: 18%;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.4), transparent 70%);
    }

    body::after {
      bottom: -10%;
      right: -5%;
      background: radial-gradient(circle, rgba(14, 165, 233, 0.35), transparent 65%);
    }

    main {
      width: min(1100px, 100%);
      display: grid;
      gap: clamp(0.9rem, 2.5vw, 1.5rem);
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-content: start;
    }

    main>.panel:first-of-type,
    main>.panel:last-of-type {
      grid-column: 1 / -1;
    }

    h1 {
      margin: 0;
      font-size: clamp(2.1rem, 4vw, 2.8rem);
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    h2 {
      margin: 0;
      font-size: clamp(1.25rem, 3vw, 1.6rem);
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    .panel {
      position: relative;
      padding: clamp(1.3rem, 3vw, 2rem);
      border-radius: 26px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.72), rgba(255, 255, 255, 0.16));
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(25px) saturate(160%);
      -webkit-backdrop-filter: blur(25px) saturate(160%);
      box-shadow: var(--glass-shadow);
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
      overflow: hidden;
      transition: transform var(--transition-slow), box-shadow var(--transition-slow), border-color var(--transition-slow);
    }

    .panel::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(150deg, rgba(255, 255, 255, 0.45) 0%, rgba(255, 255, 255, 0.05) 65%);
      opacity: 0.75;
      pointer-events: none;
      z-index: 0;
    }

    .panel>* {
      position: relative;
      z-index: 1;
    }

    .panel:focus-within {
      box-shadow: 0 28px 56px -28px rgba(15, 23, 42, 0.65);
      border-color: rgba(255, 255, 255, 0.72);
    }

    .panel header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .panel-status {
      transition: background 0.45s ease, border-color 0.45s ease, box-shadow 0.45s ease;
    }

    .panel-status.status-gray {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.72), rgba(255, 255, 255, 0.16));
      border-color: rgba(255, 255, 255, 0.55);
      box-shadow: var(--glass-shadow);
    }

    .panel-status.status-blue {
      background: linear-gradient(140deg, rgba(96, 165, 250, 0.32), rgba(14, 165, 233, 0.18));
      border-color: rgba(59, 130, 246, 0.45);
      box-shadow: 0 36px 72px -30px rgba(37, 99, 235, 0.58);
    }

    .panel-status.status-green {
      background: linear-gradient(140deg, rgba(134, 239, 172, 0.4), rgba(16, 185, 129, 0.2));
      border-color: rgba(34, 197, 94, 0.45);
      box-shadow: 0 36px 72px -30px rgba(16, 185, 129, 0.5);
    }

    .panel-status.status-red {
      background: linear-gradient(140deg, rgba(252, 165, 165, 0.4), rgba(248, 113, 113, 0.2));
      border-color: rgba(239, 68, 68, 0.45);
      box-shadow: 0 36px 72px -30px rgba(239, 68, 68, 0.5);
    }

    .panel-status.status-amber {
      background: linear-gradient(140deg, rgba(253, 230, 138, 0.45), rgba(249, 115, 22, 0.22));
      border-color: rgba(249, 115, 22, 0.45);
      box-shadow: 0 36px 72px -30px rgba(249, 115, 22, 0.48);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #ffffff;
      background-image: linear-gradient(135deg, rgba(148, 163, 184, 0.8), rgba(71, 85, 105, 0.9));
      box-shadow: 0 12px 30px -18px rgba(15, 23, 42, 0.85);
      animation: badgePulse 3s ease-in-out infinite;
    }

    .status-badge.blue {
      background-image: linear-gradient(135deg, #60a5fa, #2563eb);
      box-shadow: 0 12px 30px -15px rgba(37, 99, 235, 0.6);
    }

    .status-badge.green {
      background-image: linear-gradient(135deg, #34d399, #059669);
      box-shadow: 0 12px 30px -15px rgba(5, 150, 105, 0.55);
    }

    .status-badge.gray {
      background-image: linear-gradient(135deg, #e2e8f0, #cbd5f5);
      color: #1f2937;
      box-shadow: 0 12px 30px -15px rgba(15, 23, 42, 0.4);
    }

    .status-badge.red {
      background-image: linear-gradient(135deg, #fda4af, #ef4444);
      box-shadow: 0 12px 30px -15px rgba(239, 68, 68, 0.55);
    }

    .status-badge.amber {
      background-image: linear-gradient(135deg, #fcd34d, #f97316);
      box-shadow: 0 12px 30px -15px rgba(249, 115, 22, 0.45);
    }

    .sheet-selector {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .sheet-selector label {
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .sheet-selector select {
      border-radius: 20px;
      padding: 0.7rem 1rem;
      font-size: 1rem;
      color: #0f172a;
      background: rgba(255, 255, 255, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 12px 30px -20px rgba(99, 102, 241, 0.45);
      transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
      appearance: none;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .sheet-selector select:hover:not(:disabled) {
      border-color: rgba(99, 102, 241, 0.6);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 18px 36px -22px rgba(99, 102, 241, 0.45);
    }

    .sheet-selector select:focus-visible {
      outline: none;
      border-color: rgba(99, 102, 241, 0.9);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.25);
    }

    .sheet-selector select:disabled {
      background: rgba(226, 232, 240, 0.65);
      color: rgba(71, 85, 105, 0.8);
      opacity: 0.8;
      cursor: not-allowed;
      box-shadow: none;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: 20px;
      padding: 0.85rem 1.4rem;
      font-size: 1rem;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      isolation: isolate;
      transition: transform 0.35s ease, box-shadow 0.35s ease, filter 0.35s ease;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.6), rgba(148, 163, 184, 0.5));
      color: #0f172a;
      box-shadow: 0 18px 36px -22px rgba(15, 23, 42, 0.55);
    }

    button::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.45), transparent 65%);
      opacity: 0;
      transform: scale(0);
      transition: transform 0.6s ease, opacity 0.6s ease;
      pointer-events: none;
      z-index: 0;
    }

    button>* {
      position: relative;
      z-index: 1;
    }

    button:hover:not(:disabled) {
      transform: translateY(-4px);
      box-shadow: 0 24px 48px -26px rgba(37, 99, 235, 0.6);
      filter: brightness(1.02);
    }

    button:active:not(:disabled) {
      transform: translateY(-1px) scale(0.98);
    }

    button:active::after {
      opacity: 0.8;
      transform: scale(3.2);
      transition-duration: 0.35s;
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.35), 0 20px 40px -25px rgba(37, 99, 235, 0.55);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
      box-shadow: none;
    }

    button:disabled::after {
      opacity: 0;
    }

    button.primary {
      background: linear-gradient(135deg, #6366f1, #0ea5e9);
      color: #ffffff;
      box-shadow: 0 22px 48px -25px rgba(14, 165, 233, 0.55);
    }

    button.primary:hover:not(:disabled) {
      box-shadow: 0 28px 56px -25px rgba(14, 165, 233, 0.6);
    }

    button.secondary {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(226, 232, 255, 0.75));
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: #0f172a;
      box-shadow: 0 18px 36px -26px rgba(148, 163, 184, 0.55);
    }

    button.secondary:hover:not(:disabled) {
      box-shadow: 0 20px 42px -24px rgba(148, 163, 184, 0.55);
      filter: brightness(1.05);
    }

    button.is-locked {
      filter: saturate(0.75);
    }

    button.is-locked::after {
      opacity: 0;
    }

    .feedback-popup {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1.25rem, 5vw, 3rem);
      background: rgba(15, 23, 42, 0.45);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.4s ease, visibility 0.4s ease;
    }

    .feedback-popup.visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .feedback-popup__content {
      width: min(400px, 100%);
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.78), rgba(255, 255, 255, 0.2));
      border-radius: 26px;
      padding: clamp(1.2rem, 3vw, 1.8rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      border: 1px solid rgba(255, 255, 255, 0.6);
      box-shadow: 0 28px 60px -24px rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      transform: translateY(24px);
      opacity: 0;
      transition: transform 0.45s ease, opacity 0.45s ease;
    }

    .feedback-popup.visible .feedback-popup__content {
      transform: translateY(0);
      opacity: 1;
    }

    .feedback-popup.is-success .feedback-popup__content {
      border-color: rgba(34, 197, 94, 0.55);
      box-shadow: 0 28px 60px -24px rgba(16, 185, 129, 0.45);
    }

    .feedback-popup.is-error .feedback-popup__content {
      border-color: rgba(239, 68, 68, 0.55);
      box-shadow: 0 28px 60px -24px rgba(239, 68, 68, 0.4);
    }

    .feedback-popup.is-info .feedback-popup__content {
      border-color: rgba(59, 130, 246, 0.55);
      box-shadow: 0 28px 60px -24px rgba(59, 130, 246, 0.4);
    }

    .feedback-popup__message {
      font-size: 1rem;
      line-height: 1.5;
      color: #0f172a;
    }

    .feedback-popup__actions {
      display: flex;
      justify-content: flex-end;
    }

    .feedback-popup__close {
      background: linear-gradient(135deg, #6366f1, #0ea5e9);
      color: #fff;
      border: none;
      border-radius: 20px;
      font-weight: 600;
      padding: 0.6rem 1.4rem;
      cursor: pointer;
      box-shadow: 0 16px 30px -20px rgba(14, 165, 233, 0.6);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .feedback-popup__close:hover {
      transform: translateY(-3px);
      box-shadow: 0 22px 40px -22px rgba(14, 165, 233, 0.55);
    }

    .feedback-popup__close:active {
      transform: translateY(-1px);
    }

    .captcha-area {
      display: flex;
      gap: clamp(0.5rem, 2vw, 0.75rem);
      flex-wrap: nowrap;
      align-items: center;
      width: 100%;
    }

    .captcha-area input {
      flex: 1 1 auto;
      min-width: 0;
      padding: clamp(0.65rem, 2vw, 0.85rem);
      font-size: clamp(1.1rem, 4vw, 1.35rem);
      font-weight: 700;
      text-align: center;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      letter-spacing: clamp(0.28rem, 2.5vw, 0.42rem);
      background: rgba(255, 255, 255, 0.75);
      box-shadow: inset 0 2px 6px rgba(15, 23, 42, 0.08), 0 14px 28px -24px rgba(37, 99, 235, 0.45);
      transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
      caret-color: #6366f1;
    }

    .captcha-area button {
      flex: 0 0 auto;
      padding: clamp(0.6rem, 2vw, 0.75rem) clamp(0.9rem, 4vw, 1.1rem);
      min-width: 110px;
      border-radius: 18px;
    }

    .captcha-area input::placeholder {
      color: rgba(148, 163, 184, 0.6);
    }

    .captcha-area input:focus {
      outline: none;
      border-color: rgba(37, 99, 235, 0.65);
      box-shadow: 0 0 0 5px rgba(99, 102, 241, 0.25);
      background: rgba(255, 255, 255, 0.92);
    }

    .image-box {
      border: 1px dashed rgba(148, 163, 184, 0.4);
      background: rgba(255, 255, 255, 0.32);
      border-radius: 24px;
      padding: clamp(0.9rem, 2.5vw, 1.4rem);
      display: flex;
      align-items: center;
      justify-content: center;
      max-width: 100%;
      align-self: center;
      text-align: center;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35), 0 20px 40px -30px rgba(15, 23, 42, 0.6);
      transition: border-color 0.3s ease, box-shadow 0.3s ease, padding 0.3s ease, background 0.3s ease;
    }

    .image-box.has-image {
      display: inline-flex;
      min-height: 0;
      padding: 0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.58);
      box-shadow: 0 24px 48px -32px rgba(37, 99, 235, 0.35);
    }

    .image-box.empty span {
      color: rgba(100, 116, 139, 0.85);
    }

    .image-box:hover {
      border-color: rgba(99, 102, 241, 0.5);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.5), 0 24px 44px -32px rgba(59, 130, 246, 0.45);
    }

    .image-box.has-image:hover {
      box-shadow: 0 28px 52px -30px rgba(14, 165, 233, 0.45);
    }

    .image-box img {
      display: block;
      object-fit: contain;
      width: auto;
      height: auto;
      max-width: min(100%, 460px);
    }

    .latest-log {
      margin-top: 0.75rem;
      padding: 1.2rem 1.4rem;
      border-radius: 22px;
      background: rgba(255, 255, 255, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 1rem;
      color: #0f172a;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
      min-height: 90px;
      line-height: 1.55;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .sheet-preview table {
      width: 100%;
      border-collapse: collapse;
      border-radius: 22px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.35);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
    }

    .sheet-preview th,
    .sheet-preview td {
      border: 1px solid rgba(226, 232, 240, 0.65);
      padding: 0.75rem;
      font-size: 0.95rem;
      text-align: left;
      color: #0f172a;
    }

    .sheet-preview th {
      background: linear-gradient(135deg, rgba(226, 232, 240, 0.9), rgba(214, 226, 255, 0.7));
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    .sheet-preview tr:hover td {
      background: rgba(226, 232, 240, 0.4);
    }

    .hidden {
      display: none !important;
    }

    @keyframes badgePulse {
      0% {
        transform: translateY(0);
        box-shadow: 0 12px 30px -18px rgba(15, 23, 42, 0.6);
      }

      50% {
        transform: translateY(-1px);
        box-shadow: 0 14px 34px -18px rgba(59, 130, 246, 0.45);
      }

      100% {
        transform: translateY(0);
        box-shadow: 0 12px 30px -18px rgba(15, 23, 42, 0.6);
      }
    }

    @media (max-width: 768px) {
      body {
        padding: clamp(1rem, 6vw, 2.5rem);
      }

      main {
        grid-template-columns: 1fr;
      }

      .captcha-area input {
        letter-spacing: 0.32rem;
      }
    }

    @media (max-width: 480px) {
      .panel {
        padding: 1.25rem;
      }

      .captcha-area input {
        font-size: 1.05rem;
        letter-spacing: 0.24rem;
        padding: 0.6rem 0.7rem;
      }

      .captcha-area button {
        min-width: 96px;
        padding: 0.55rem 0.85rem;
      }
    }

    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>

<body>
  <div id="feedback" class="feedback-popup hidden">
    <div class="feedback-popup__content">
      <div id="feedbackMessage" class="feedback-popup__message"></div>
      <div class="feedback-popup__actions">
        <button type="button" id="feedbackClose" class="feedback-popup__close">
          Close
        </button>
      </div>
    </div>
  </div>
  <main>
    <section id="statusPanel" class="panel panel-status status-gray">
      <header>
        <h1>Auto Login</h1>
        <span id="pollingBadge" class="status-badge gray hidden">Idle</span>
      </header>
    </section>

    <section class="panel">
      <div id="latestLog" class="latest-log">
        No log entries yet.
      </div>
    </section>

    <section class="panel">
      <header>
        <h2>Control Panel</h2>
        <span id="runningBadge" class="status-badge blue hidden">Running...</span>
      </header>
      <div class="sheet-selector">
        <label for="sheetSelector">Sheet</label>
        <select id="sheetSelector" disabled>
          <option>Loading...</option>
        </select>
      </div>
      <button id="runButton" class="primary">
        <span id="runButtonText">RUN LOGIN</span>
      </button>
      <button id="stopPollingButton" class="secondary hidden">
        Stop Polling
      </button>
    </section>

    <section class="panel">
      <h2>Captcha Image</h2>
      <div class="image-box empty" id="captchaContainer">
        <span>No image available.</span>
      </div>
    </section>

    <section class="panel">
      <h2>Enter Captcha</h2>
      <div class="captcha-area">
        <input id="captchaInput" type="text" placeholder="000" inputmode="numeric" maxlength="3"
          aria-label="Captcha answer (3 digits)" />
        <button id="submitButton" class="secondary">Send</button>
      </div>
    </section>

  </main>

  <script>
    const POLL_INTERVAL_MS = 2000;
    const state = {
      loading: false,
      polling: false,
      running: false,
      pollHandle: null,
      values: [],
      lastRunStatus: '',
      sheetName: '',
      sheets: [],
    };

    const runButton = document.getElementById('runButton');
    const runButtonText = document.getElementById('runButtonText');
    const stopPollingButton = document.getElementById('stopPollingButton');
    const sheetSelector = document.getElementById('sheetSelector');
    const submitButton = document.getElementById('submitButton');
    const captchaInput = document.getElementById('captchaInput');
    const feedbackPopup = document.getElementById('feedback');
    const feedbackMessageEl = document.getElementById('feedbackMessage');
    const feedbackCloseButton = document.getElementById('feedbackClose');
    const captchaContainer = document.getElementById('captchaContainer');
    const latestLogEl = document.getElementById('latestLog');
    const sheetTableContainer = document.getElementById(
      'sheetTableContainer'
    );
    const refreshButton = document.getElementById('refreshButton');
    const runningBadge = document.getElementById('runningBadge');
    const pollingBadge = document.getElementById('pollingBadge');
    const statusPanel = document.getElementById('statusPanel');
    const loadingBadge = document.getElementById('loadingBadge');
    const rootElement = document.documentElement;

    const FEEDBACK_TYPES = ['success', 'error', 'info'];
    const STATUS_BADGE_VARIANTS = ['gray', 'green', 'blue', 'red', 'amber'];

    function updateViewportHeight() {
      const viewport = window.visualViewport;
      const height = viewport ? viewport.height : window.innerHeight;
      if (height) {
        rootElement.style.setProperty('--app-vh', `${height}px`);
      }
    }

    updateViewportHeight();

    const detachViewportListeners = (() => {
      const handler = () => updateViewportHeight();
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', handler);
        window.visualViewport.addEventListener('scroll', handler);
      } else {
        window.addEventListener('resize', handler);
      }
      window.addEventListener('orientationchange', handler);
      return () => {
        if (window.visualViewport) {
          window.visualViewport.removeEventListener('resize', handler);
          window.visualViewport.removeEventListener('scroll', handler);
        } else {
          window.removeEventListener('resize', handler);
        }
        window.removeEventListener('orientationchange', handler);
      };
    })();

    function resolveStatusVariant(status) {
      switch (status) {
        case 'RUN':
          return 'blue';
        case 'DONE':
          return 'green';
        case 'ERROR':
          return 'red';
        case 'PENDING':
          return 'amber';
        default:
          return 'gray';
      }
    }

    function refreshRunButtonState() {
      if (!runButton) {
        return;
      }
      const normalized = normalizeStatus(state.lastRunStatus);
      const isPending = normalized === 'PENDING';
      const isRunningStatus = normalized === 'RUN';
      const shouldDisable =
        state.running || !state.sheetName || isPending || isRunningStatus;
      runButton.disabled = shouldDisable;
      runButton.classList.toggle('is-locked', isPending || isRunningStatus);

      if (isPending) {
        runButton.title = 'Status is PENDING. Please wait until it changes.';
      } else if (isRunningStatus) {
        runButton.title = 'Status is RUN. Please wait for completion.';
      } else if (state.running) {
        runButton.title = 'Request already in progress.';
      } else if (!state.sheetName) {
        runButton.title = 'Select a sheet to start.';
      } else {
        runButton.removeAttribute('title');
      }
    }

    function updateActionButtons() {
      if (!runButton || !stopPollingButton) {
        return;
      }
      const showStop =
        state.running ||
        state.polling ||
        normalizeStatus(state.lastRunStatus) === 'RUN';
      runButton.classList.toggle('hidden', showStop);
      stopPollingButton.classList.toggle('hidden', !showStop);
    }

    function setFeedback(type, message) {
      if (!message || typeof message !== 'string' || !message.trim()) {
        clearFeedback();
        return;
      }

      clearFeedback();
      if (latestLogEl && message) {
        latestLogEl.textContent = message;
      }
    }

    function clearFeedback() {
      if (!feedbackPopup || !feedbackMessageEl) {
        return;
      }

      FEEDBACK_TYPES.forEach((t) =>
        feedbackPopup.classList.remove(`is-${t}`)
      );
      feedbackPopup.classList.remove('visible');
      feedbackPopup.classList.add('hidden');
      feedbackMessageEl.textContent = '';
    }

    function setStatusPanelVariant(variant) {
      if (!statusPanel) {
        return;
      }
      const applied = STATUS_BADGE_VARIANTS.includes(variant)
        ? variant
        : 'gray';
      STATUS_BADGE_VARIANTS.forEach((color) => {
        statusPanel.classList.toggle(`status-${color}`, color === applied);
      });
    }

    function updateStatusBadge(label, variant = 'gray') {
      if (!pollingBadge) {
        return;
      }
      const safeLabel =
        typeof label === 'string' && label.trim()
          ? label.trim()
          : 'IDLE';
      pollingBadge.textContent = safeLabel;
      STATUS_BADGE_VARIANTS.forEach((color) => {
        pollingBadge.classList.toggle(color, color === variant);
      });
      pollingBadge.classList.remove('hidden');
      setStatusPanelVariant(variant);
    }

    function setSheetName(name) {
      const normalized = typeof name === 'string' ? name : '';
      state.sheetName = normalized;
      if (sheetSelector) {
        sheetSelector.value = normalized;
      }
      state.lastRunStatus = '';
      refreshRunButtonState();
      updateActionButtons();
      updateSubmitDisabled();
    }

    function renderSheetOptions(options) {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.innerHTML = '';
      const fragment = document.createDocumentFragment();

      // ?? Thêm placeholder tr?ng làm m?c d?nh
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select sheet';
      placeholder.disabled = true;
      placeholder.selected = true;
      fragment.appendChild(placeholder);

      // ?? Thêm danh sách các sheet th?t s?
      options.forEach((sheet) => {
        const option = document.createElement('option');
        option.value = sheet.title;
        option.textContent = sheet.title;
        if (sheet.id !== null && sheet.id !== undefined) {
          option.dataset.sheetId = String(sheet.id);
        }
        fragment.appendChild(option);
      });

      sheetSelector.appendChild(fragment);

      // ?? Không ch?n sheet m?c d?nh nào h?t
      setSheetName('');
      sheetSelector.value = '';

      // ?? Tr?ng thái hi?n th? v?n là “IDLE”
      updateStatusBadge('IDLE', 'gray');
      sheetSelector.disabled = false;
    }

    async function fetchSheetList() {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.disabled = true;
      sheetSelector.innerHTML = '<option>Loading...</option>';

      try {
        const response = await fetch('/sheets');
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(
            body.error || `Request failed (${response.status})`
          );
        }

        const data = await response.json();
        const sheets = Array.isArray(data.sheets) ? data.sheets : [];
        const defaultSheet = data.defaultSheet;

        state.sheets = sheets;

        if (!sheets.length) {
          sheetSelector.innerHTML =
            '<option value=\"\">No sheets found</option>';
          setSheetName('');
          updateStatusBadge('IDLE', 'gray');
          setFeedback('error', 'No sheets available in this spreadsheet.');
          return;
        }

        renderSheetOptions(sheets, defaultSheet);
      } catch (error) {
        console.error('Failed to fetch sheet list:', error);
        sheetSelector.innerHTML = '<option value=\"\">Load failed</option>';
        setSheetName('');
        updateStatusBadge('IDLE', 'gray');
        state.sheets = [];
        setFeedback('error', error.message || 'Failed to load sheet list.');
        throw error;
      } finally {
        sheetSelector.disabled = state.sheets.length === 0;
      }
    }

    function toggleRunning(isRunning) {
      state.running = isRunning;
      refreshRunButtonState();
      runningBadge.classList.toggle('hidden', !isRunning);
      runButtonText.textContent = isRunning ? 'Sending...' : 'RUN LOGIN';
      updateActionButtons();
    }

    function togglePolling(isPolling) {
      state.polling = isPolling;
      if (!isPolling && (!state.lastRunStatus || state.lastRunStatus === 'RUN')) {
        updateStatusBadge('IDLE', 'gray');
      }
      updateActionButtons();
    }

    function toggleLoading(isLoading) {
      state.loading = isLoading;
      if (loadingBadge) {
        loadingBadge.classList.toggle('hidden', !isLoading);
      }
    }

    function restrictCaptchaInput(value) {
      return value.replace(/\D/g, '').slice(0, 3);
    }

    function getCellValue(values, cellLabel) {
      if (!cellLabel) {
        return '';
      }
      const match = /^([A-Za-z]+)(\d+)$/.exec(cellLabel);
      if (!match) {
        return '';
      }
      const [, letters, rowStr] = match;
      const rowIndex = parseInt(rowStr, 10) - 1;
      if (Number.isNaN(rowIndex) || rowIndex < 0) {
        return '';
      }
      let colIndex = 0;
      for (let i = 0; i < letters.length; i += 1) {
        colIndex *= 26;
        colIndex += letters.toUpperCase().charCodeAt(i) - 64;
      }
      colIndex -= 1;
      if (!values[rowIndex]) {
        return '';
      }
      return values[rowIndex][colIndex] ?? '';
    }

    function resolveImageSource(raw) {
      if (!raw) {
        return null;
      }
      const trimmed = String(raw).trim();
      if (!trimmed) {
        return null;
      }

      const noWhitespace = trimmed.replace(/\s+/g, '');
      const sanitized = noWhitespace.replace(/^["']+|["']+$/g, '');
      if (!sanitized) {
        return null;
      }

      if (
        sanitized.startsWith('http://') ||
        sanitized.startsWith('https://') ||
        sanitized.startsWith('data:')
      ) {
        return sanitized;
      }

      const base64Candidate = sanitized.startsWith('base64,')
        ? sanitized.substring('base64,'.length)
        : sanitized;

      const padding = base64Candidate.length % 4;
      const padded =
        padding === 0
          ? base64Candidate
          : `${base64Candidate}${'='.repeat(4 - padding)}`;

      try {
        if (typeof window !== 'undefined' && typeof window.atob === 'function') {
          window.atob(padded);
        }
        return `data:image/png;base64,${padded}`;
      } catch (error) {
        console.warn('Invalid base64 captcha image', error);
        return null;
      }
    }

    function renderCaptcha(values) {
      let rawImage = getCellValue(values, 'C2');
      let source = resolveImageSource(rawImage);
      if (!source) {
        rawImage = getCellValue(values, 'B2');
        source = resolveImageSource(rawImage);
      }
      captchaContainer.innerHTML = '';
      captchaContainer.classList.remove('has-image', 'empty');
      captchaContainer.style.removeProperty('width');
      captchaContainer.style.removeProperty('height');
      if (source) {
        const img = document.createElement('img');
        img.src = source;
        img.alt = 'Captcha from Google Sheet';
        captchaContainer.classList.add('has-image');
        captchaContainer.appendChild(img);
      } else {
        const span = document.createElement('span');
        span.textContent = 'No image available.';
        captchaContainer.classList.add('empty');
        captchaContainer.appendChild(span);
      }
    }

    function renderLogs(values) {
      if (!latestLogEl) {
        return;
      }

      const rows = Array.isArray(values) ? values.slice(1) : [];
      let latestEntry = '';

      for (let i = rows.length - 1; i >= 0; i -= 1) {
        const row = rows[i];
        if (!row || row.length <= 4) {
          continue;
        }
        const text = String(row[4] ?? '').trim();
        if (text.length > 0) {
          latestEntry = text;
          break;
        }
      }

      if (latestEntry) {
        latestLogEl.textContent = latestEntry;
      } else {
        latestLogEl.textContent = 'No log entries yet.';
      }
    }

    function renderTable(values) {
      if (!sheetTableContainer) {
        return;
      }
      sheetTableContainer.innerHTML = '';
      if (!Array.isArray(values) || !values.length) {
        const empty = document.createElement('p');
        empty.style.margin = '0';
        empty.style.color = '#6b7280';
        empty.textContent = 'No data found in this sheet.';
        sheetTableContainer.appendChild(empty);
        return;
      }

      const table = document.createElement('table');
      const tbody = document.createElement('tbody');

      values.forEach((row) => {
        const tr = document.createElement('tr');
        row.forEach((cell) => {
          const td = document.createElement('td');
          td.textContent = cell ?? '';
          tr.appendChild(td);
        });
        if (!row.length) {
          const td = document.createElement('td');
          td.textContent = '';
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      sheetTableContainer.appendChild(table);
    }

    function normalizeStatus(value) {
      if (typeof value === 'string') {
        return value.trim().toUpperCase();
      }
      if (value == null) {
        return '';
      }
      return String(value).trim().toUpperCase();
    }

    function handleRunState(values) {
      const rawStatus = getCellValue(values, 'A2');
      const normalizedStatus = normalizeStatus(rawStatus);
      const statusChanged = normalizedStatus !== state.lastRunStatus;
      const variant = resolveStatusVariant(normalizedStatus);

      if (normalizedStatus === 'RUN') {
        updateStatusBadge(normalizedStatus || 'RUN', variant);
        stopPollingButton.classList.remove('hidden');
        state.lastRunStatus = normalizedStatus;
        refreshRunButtonState();
        updateActionButtons();
        return;
      }

      stopPolling();
      toggleRunning(false);

      if (statusChanged) {
        if (normalizedStatus === 'DONE' || normalizedStatus === 'ERROR') {
          const message =
            normalizedStatus === 'DONE'
              ? 'Run completed successfully.'
              : 'Run finished with ERROR status.';
          const feedbackType =
            normalizedStatus === 'DONE' ? 'success' : 'error';

          setFeedback(feedbackType, message);
        } else {
          clearFeedback();
        }
      } else if (!normalizedStatus) {
        clearFeedback();
      }

      const label = normalizedStatus || 'IDLE';
      const badgeVariant = normalizedStatus ? variant : 'gray';
      updateStatusBadge(label, badgeVariant);

      state.lastRunStatus = normalizedStatus;
      refreshRunButtonState();
      updateActionButtons();
    }
    async function fetchSheetValues() {
      if (!state.sheetName) {
        setFeedback('info', 'Select a sheet to load data.');
        return [];
      }

      toggleLoading(true);
      try {
        const response = await fetch('/sheet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'get-state', sheetName: state.sheetName }),
        });
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(body.error || `Request failed (${response.status})`);
        }
        const data = await response.json();
        const values = data.values || data.state?.values || [];
        state.values = values;
        renderCaptcha(values);
        renderLogs(values);
        renderTable(values);
        handleRunState(values);
        return values;
      } finally {
        toggleLoading(false);
      }
    }

    function startPolling() {
      if (state.polling) {
        return;
      }
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }
      togglePolling(true);
      state.pollHandle = setInterval(() => {
        fetchSheetValues().catch((error) => {
          console.error('Failed to poll sheet:', error);
          setFeedback('error', error.message);
          stopPolling();
        });
      }, POLL_INTERVAL_MS);
      fetchSheetValues().catch((error) => {
        console.error('Failed to fetch sheet:', error);
        setFeedback('error', error.message);
        stopPolling();
      });
    }

    function stopPolling() {
      if (state.pollHandle) {
        clearInterval(state.pollHandle);
        state.pollHandle = null;
      }
      togglePolling(false);
    }

    async function updateCell(cell, value) {
      if (!state.sheetName) {
        throw new Error('Please select a sheet before updating.');
      }

      const response = await fetch('/sheet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'update-cell',
          cell,
          value,
          sheetName: state.sheetName,
        }),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(data.error || 'Failed to update cell.');
      }
      return data;
    }

    async function handleRunClick() {
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }

      clearFeedback();
      toggleRunning(true);
      try {
        await updateCell('A2', 'RUN');
        setFeedback('info', 'RUN LOGIN has been triggered.');
        startPolling();
      } catch (error) {
        console.error('RUN LOGIN failed:', error);
        setFeedback('error', error.message || 'RUN LOGIN failed.');
        stopPolling();
      } finally {
        toggleRunning(false);
      }
    }

    let submitting = false;

    function updateSubmitDisabled() {
      submitButton.disabled =
        submitting || !state.sheetName || captchaInput.value.length !== 3;
    }

    async function handleSubmitClick() {
      const trimmed = captchaInput.value.trim();
      if (trimmed.length !== 3) {
        setFeedback('error', 'Please enter exactly 3 digits before sending.');
        return;
      }

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before sending captcha.');
        return;
      }

      submitting = true;
      updateSubmitDisabled();
      clearFeedback();
      try {
        await updateCell('D2', trimmed);
        setFeedback('success', 'Captcha code saved to cell D2.');
        captchaInput.value = '';
        await fetchSheetValues();
      } catch (error) {
        console.error('Submit captcha failed:', error);
        setFeedback('error', error.message || 'Failed to submit captcha.');
      } finally {
        submitting = false;
        updateSubmitDisabled();
      }
    }

    async function handleStopPollingClick() {
      stopPolling();
      toggleRunning(false);

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before stopping.');
        return;
      }

      try {
        if (state.lastRunStatus === 'RUN') {
          await updateCell('A2', 'DONE');
          state.lastRunStatus = 'DONE';
          setFeedback('success', 'Status set to DONE.');
          await fetchSheetValues();
        } else {
          setFeedback('info', 'Polling stopped. Click RUN LOGIN to resume.');
        }
      } catch (error) {
        console.error('Stop polling update failed:', error);
        setFeedback('error', error.message || 'Failed to stop run.');
      }
    }

    runButton.addEventListener('click', handleRunClick);
    submitButton.addEventListener('click', handleSubmitClick);
    stopPollingButton.addEventListener('click', handleStopPollingClick);
    if (sheetSelector) {
      sheetSelector.addEventListener('change', (event) => {
        const value = event.target.value;
        setSheetName(value);
        stopPolling();
        toggleRunning(false);
        if (!value) {
          clearFeedback();
          return;
        }
        fetchSheetValues().catch((error) => {
          console.error('Sheet change fetch failed:', error);
          setFeedback('error', error.message || 'Failed to load sheet.');
        });
      });
    }

    if (feedbackCloseButton) {
      feedbackCloseButton.addEventListener('click', () => {
        clearFeedback();
      });
    }

    if (feedbackPopup) {
      feedbackPopup.addEventListener('click', (event) => {
        if (event.target === feedbackPopup) {
          clearFeedback();
        }
      });
    }

    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && feedbackPopup && feedbackPopup.classList.contains('visible')) {
        clearFeedback();
      }
    });
    if (refreshButton) {
      refreshButton.addEventListener('click', () => {
        fetchSheetValues().catch((error) => {
          console.error('Refresh failed:', error);
          setFeedback('error', error.message);
        });
      });
    }

    captchaInput.addEventListener('input', (event) => {
      const digitsOnly = restrictCaptchaInput(event.target.value);
      event.target.value = digitsOnly;
      updateSubmitDisabled();
    });

    window.addEventListener('focus', () => {
      if (state.polling) {
        fetchSheetValues().catch((error) => {
          console.error('Refresh on focus failed:', error);
        });
      }
    });

    window.addEventListener('beforeunload', () => {
      stopPolling();
      if (typeof detachViewportListeners === 'function') {
        detachViewportListeners();
      }
    });

    // Initial load
    async function initializeDashboard() {
      updateSubmitDisabled();
      refreshRunButtonState();
      updateActionButtons();
      try {
        await fetchSheetList();
        if (state.sheetName) {
          await fetchSheetValues();
        }
      } catch (error) {
        console.error('Initialization failed:', error);
        if (!state.sheetName) {
          setFeedback('error', error.message || 'Initialization failed.');
        }
      }
    }
    (function () {
      // Hàm cập nhật chiều cao thật của viewport
      function updateViewportHeight() {
        const app = document.getElementById('app');
        if (app) {
          app.style.minHeight = window.innerHeight + 'px';
        }
      }

      // Cập nhật khi resize (mở/đóng bàn phím)
      window.addEventListener('resize', updateViewportHeight);
      window.addEventListener('orientationchange', updateViewportHeight);
      window.addEventListener('load', updateViewportHeight);

      // Fix layout sau khi bàn phím đóng
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
          if (document.activeElement && document.activeElement.tagName === 'INPUT') return;
          setTimeout(() => {
            window.scrollTo(0, 0);
            updateViewportHeight();
          }, 300);
        });
      }

      updateViewportHeight();
    })();

    initializeDashboard();
  </script>
</body>

</html>