<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Auto Login Dashboard</title>
  <style>
    :root {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #1f2933;
      background-color: #f5f7fa;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      padding: 2.5rem 1.5rem;
    }

    main {
      width: min(960px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    h1 {
      margin: 0;
      font-size: 2rem;
      font-weight: 600;
    }

    h2 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .panel {
      background-color: #fff;
      border: 1px solid #d2d6dc;
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .panel header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .status-badge {
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .status-badge.blue {
      background-color: #dbeafe;
      color: #1d4ed8;
    }

    .status-badge.green {
      background-color: #dcfce7;
      color: #15803d;
    }

    .status-badge.gray {
      background-color: #e5e7eb;
      color: #4b5563;
    }

    .status-badge.red {
      background-color: #fee2e2;
      color: #b91c1c;
    }

    .sheet-selector {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .sheet-selector label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f2937;
    }

    .sheet-selector select {
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 0.55rem 0.75rem;
      font-size: 1rem;
      background-color: #fff;
      color: #1f2937;
    }

    .sheet-selector select:disabled {
      background-color: #f1f5f9;
      color: #9ca3af;
      cursor: not-allowed;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: 8px;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      font-weight: 600;
      transition: background-color 0.2s ease, transform 0.15s ease;
    }

    button.primary {
      background-color: #2563eb;
      color: #fff;
    }

    button.primary:hover:not(:disabled) {
      background-color: #1e4ed8;
    }

    button.primary:active:not(:disabled) {
      transform: translateY(1px);
    }

    button.secondary {
      background-color: #e5edff;
      color: #1f3a8a;
      border: 1px solid #c3d4ff;
    }

    button.secondary:hover:not(:disabled) {
      background-color: #d0dcff;
    }

    button:disabled {
      background-color: #93c5fd;
      cursor: not-allowed;
      transform: none;
    }

    .feedback-popup {
      position: fixed;
      inset: 0;
      background-color: rgba(15, 23, 42, 0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1000;
    }

    .feedback-popup.visible {
      display: flex;
    }

    .feedback-popup__content {
      width: min(360px, 100%);
      background-color: #ffffff;
      border-radius: 14px;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
      border: 1px solid #e2e8f0;
    }

    .feedback-popup.is-success .feedback-popup__content {
      border-left: 4px solid #16a34a;
    }

    .feedback-popup.is-error .feedback-popup__content {
      border-left: 4px solid #dc2626;
    }

    .feedback-popup.is-info .feedback-popup__content {
      border-left: 4px solid #2563eb;
    }

    .feedback-popup__message {
      font-size: 1rem;
      color: #1f2937;
    }

    .feedback-popup__actions {
      display: flex;
      justify-content: flex-end;
    }

    .feedback-popup__close {
      background-color: #1f3a8a;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      padding: 0.55rem 1.1rem;
      cursor: pointer;
    }

    .feedback-popup__close:hover {
      background-color: #1e40af;
    }

    .captcha-area {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .captcha-area input {
      flex: 1;
      min-width: 140px;
      padding: 0.75rem;
      font-size: 1.25rem;
      font-weight: 600;
      text-align: center;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      letter-spacing: 0.4rem;
    }

    .captcha-area input:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .image-box {
      border: 1px dashed #cbd5e1;
      background-color: #f8fafc;
      border-radius: 8px;
      padding: 0.5rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      max-width: 100%;
      align-self: center;
    }

    .image-box img {
      display: block;
      max-width: 100%;
      height: auto;
      object-fit: contain;
    }

    .latest-log {
      margin-top: 0.75rem;
      padding: 0.85rem 1rem;
      border-radius: 8px;
      background-color: #f8fafc;
      border: 1px solid #e2e8f0;
      font-size: 0.95rem;
      color: #1f2937;
    }

    .sheet-preview table {
      width: 100%;
      border-collapse: collapse;
      border-radius: 8px;
      overflow: hidden;
      background-color: #fff;
      border: 1px solid #d2d6dc;
    }

    .sheet-preview th,
    .sheet-preview td {
      border: 1px solid #e2e8f0;
      padding: 0.6rem;
      font-size: 0.9rem;
      text-align: left;
    }

    .sheet-preview th {
      background-color: #f1f5f9;
      font-weight: 600;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div id="feedback" class="feedback-popup hidden">
    <div class="feedback-popup__content">
      <div id="feedbackMessage" class="feedback-popup__message"></div>
      <div class="feedback-popup__actions">
        <button type="button" id="feedbackClose" class="feedback-popup__close">
          Close
        </button>
      </div>
    </div>
  </div>
  <main>
    <section class="panel">
      <header>
        <h1>Auto Login</h1>
        <span id="pollingBadge" class="status-badge gray hidden">Idle</span>
      </header>
      <div id="latestLog" class="latest-log">
        No log entries yet.
      </div>
    </section>

    <section class="panel">
      <header>
        <h2>Control Panel</h2>
        <span id="runningBadge" class="status-badge blue hidden">Running...</span>
      </header>
      <div class="sheet-selector">
        <label for="sheetSelector">Sheet</label>
        <select id="sheetSelector" disabled>
          <option>Loading...</option>
        </select>
      </div>
      <button id="runButton" class="primary">
        <span id="runButtonText">RUN LOGIN</span>
      </button>
      <button id="stopPollingButton" class="secondary hidden">
        Stop Polling
      </button>
    </section>

    <section class="panel">
      <h2>Captcha Image</h2>
      <div class="image-box" id="captchaContainer">
        <span style="color: #6b7280;">No image available.</span>
      </div>
    </section>

    <section class="panel">
      <h2>Enter Captcha</h2>
      <div class="captcha-area">
        <input id="captchaInput" type="text" placeholder="000" inputmode="numeric" maxlength="3"
          aria-label="Captcha answer (3 digits)" />
        <button id="submitButton" class="secondary">Send</button>
      </div>
    </section>

  </main>

  <script>
    const POLL_INTERVAL_MS = 2000;
    const state = {
      loading: false,
      polling: false,
      running: false,
      pollHandle: null,
      values: [],
      lastRunStatus: '',
      sheetName: '',
      sheets: [],
    };

    const runButton = document.getElementById('runButton');
    const runButtonText = document.getElementById('runButtonText');
    const stopPollingButton = document.getElementById('stopPollingButton');
    const sheetSelector = document.getElementById('sheetSelector');
    const submitButton = document.getElementById('submitButton');
    const captchaInput = document.getElementById('captchaInput');
    const feedbackPopup = document.getElementById('feedback');
    const feedbackMessageEl = document.getElementById('feedbackMessage');
    const feedbackCloseButton = document.getElementById('feedbackClose');
    const captchaContainer = document.getElementById('captchaContainer');
    const latestLogEl = document.getElementById('latestLog');
    const sheetTableContainer = document.getElementById(
      'sheetTableContainer'
    );
    const refreshButton = document.getElementById('refreshButton');
    const runningBadge = document.getElementById('runningBadge');
    const pollingBadge = document.getElementById('pollingBadge');
    const loadingBadge = document.getElementById('loadingBadge');

    const FEEDBACK_TYPES = ['success', 'error', 'info'];
    const STATUS_BADGE_VARIANTS = ['gray', 'green', 'blue', 'red'];

    function setFeedback(type, message, options = {}) {
      const { popup = false } = options;

      if (!message || typeof message !== 'string' || !message.trim()) {
        clearFeedback();
        return;
      }

      if (popup && feedbackPopup && feedbackMessageEl) {
        const variant = FEEDBACK_TYPES.includes(type) ? type : 'info';
        FEEDBACK_TYPES.forEach((t) =>
          feedbackPopup.classList.remove(`is-${t}`)
        );
        feedbackPopup.classList.add(`is-${variant}`);

        feedbackMessageEl.textContent = message;
        feedbackPopup.classList.remove('hidden');
        feedbackPopup.classList.add('visible');
        return;
      }

      clearFeedback();
      if (latestLogEl && message) {
        latestLogEl.textContent = message;
      }
    }

    function clearFeedback() {
      if (!feedbackPopup || !feedbackMessageEl) {
        return;
      }

      FEEDBACK_TYPES.forEach((t) =>
        feedbackPopup.classList.remove(`is-${t}`)
      );
      feedbackPopup.classList.remove('visible');
      feedbackPopup.classList.add('hidden');
      feedbackMessageEl.textContent = '';
    }

    function updateStatusBadge(label, variant = 'gray') {
      pollingBadge.textContent = label;
      STATUS_BADGE_VARIANTS.forEach((color) => {
        pollingBadge.classList.toggle(color, color === variant);
      });
      pollingBadge.classList.remove('hidden');
    }

    function setSheetName(name) {
      const normalized = typeof name === 'string' ? name : '';
      state.sheetName = normalized;
      if (sheetSelector) {
        sheetSelector.value = normalized;
      }
      state.lastRunStatus = '';
      runButton.disabled = state.running || !state.sheetName;
      updateSubmitDisabled();
    }

    function renderSheetOptions(options) {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.innerHTML = '';
      const fragment = document.createDocumentFragment();

      // 👉 Thêm placeholder trống làm mặc định
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select sheet';
      placeholder.disabled = true;
      placeholder.selected = true;
      fragment.appendChild(placeholder);

      // 👉 Thêm danh sách các sheet thật sự
      options.forEach((sheet) => {
        const option = document.createElement('option');
        option.value = sheet.title;
        option.textContent = sheet.title;
        if (sheet.id !== null && sheet.id !== undefined) {
          option.dataset.sheetId = String(sheet.id);
        }
        fragment.appendChild(option);
      });

      sheetSelector.appendChild(fragment);

      // 👉 Không chọn sheet mặc định nào hết
      setSheetName('');
      sheetSelector.value = '';

      // 👉 Trạng thái hiển thị vẫn là “IDLE”
      updateStatusBadge('IDLE', 'gray');
      sheetSelector.disabled = false;
    }

    async function fetchSheetList() {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.disabled = true;
      sheetSelector.innerHTML = '<option>Loading...</option>';

      try {
        const response = await fetch('/sheets');
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(
            body.error || `Request failed (${response.status})`
          );
        }

        const data = await response.json();
        const sheets = Array.isArray(data.sheets) ? data.sheets : [];
        const defaultSheet = data.defaultSheet;

        state.sheets = sheets;

        if (!sheets.length) {
          sheetSelector.innerHTML =
            '<option value=\"\">No sheets found</option>';
          setSheetName('');
          updateStatusBadge('IDLE', 'gray');
          setFeedback('error', 'No sheets available in this spreadsheet.');
          return;
        }

        renderSheetOptions(sheets, defaultSheet);
      } catch (error) {
        console.error('Failed to fetch sheet list:', error);
        sheetSelector.innerHTML = '<option value=\"\">Load failed</option>';
        setSheetName('');
        updateStatusBadge('IDLE', 'gray');
        state.sheets = [];
        setFeedback('error', error.message || 'Failed to load sheet list.');
        throw error;
      } finally {
        sheetSelector.disabled = state.sheets.length === 0;
      }
    }

    function toggleRunning(isRunning) {
      state.running = isRunning;
      runButton.disabled = isRunning || !state.sheetName;
      runningBadge.classList.toggle('hidden', !isRunning);
      runButtonText.textContent = isRunning ? 'Sending...' : 'RUN LOGIN';
    }

    function togglePolling(isPolling) {
      state.polling = isPolling;
      if (isPolling) {
        updateStatusBadge('POLLING...', 'blue');
      } else if (!state.lastRunStatus || state.lastRunStatus === 'RUN') {
        updateStatusBadge('IDLE', 'gray');
      }
      stopPollingButton.classList.toggle('hidden', !isPolling);
    }

    function toggleLoading(isLoading) {
      state.loading = isLoading;
      if (loadingBadge) {
        loadingBadge.classList.toggle('hidden', !isLoading);
      }
    }

    function restrictCaptchaInput(value) {
      return value.replace(/\D/g, '').slice(0, 3);
    }

    function getCellValue(values, cellLabel) {
      if (!cellLabel) {
        return '';
      }
      const match = /^([A-Za-z]+)(\d+)$/.exec(cellLabel);
      if (!match) {
        return '';
      }
      const [, letters, rowStr] = match;
      const rowIndex = parseInt(rowStr, 10) - 1;
      if (Number.isNaN(rowIndex) || rowIndex < 0) {
        return '';
      }
      let colIndex = 0;
      for (let i = 0; i < letters.length; i += 1) {
        colIndex *= 26;
        colIndex += letters.toUpperCase().charCodeAt(i) - 64;
      }
      colIndex -= 1;
      if (!values[rowIndex]) {
        return '';
      }
      return values[rowIndex][colIndex] ?? '';
    }

    function resolveImageSource(raw) {
      if (!raw) {
        return null;
      }
      const trimmed = String(raw).trim();
      if (!trimmed) {
        return null;
      }

      const noWhitespace = trimmed.replace(/\s+/g, '');
      const sanitized = noWhitespace.replace(/^["']+|["']+$/g, '');
      if (!sanitized) {
        return null;
      }

      if (
        sanitized.startsWith('http://') ||
        sanitized.startsWith('https://') ||
        sanitized.startsWith('data:')
      ) {
        return sanitized;
      }

      const base64Candidate = sanitized.startsWith('base64,')
        ? sanitized.substring('base64,'.length)
        : sanitized;

      const padding = base64Candidate.length % 4;
      const padded =
        padding === 0
          ? base64Candidate
          : `${base64Candidate}${'='.repeat(4 - padding)}`;

      try {
        if (typeof window !== 'undefined' && typeof window.atob === 'function') {
          window.atob(padded);
        }
        return `data:image/png;base64,${padded}`;
      } catch (error) {
        console.warn('Invalid base64 captcha image', error);
        return null;
      }
    }

    function renderCaptcha(values) {
      let rawImage = getCellValue(values, 'C2');
      let source = resolveImageSource(rawImage);
      if (!source) {
        rawImage = getCellValue(values, 'B2');
        source = resolveImageSource(rawImage);
      }
      captchaContainer.innerHTML = '';
      if (source) {
        const img = document.createElement('img');
        img.src = source;
        img.alt = 'Captcha from Google Sheet';
        captchaContainer.appendChild(img);
      } else {
        const span = document.createElement('span');
        span.style.color = '#6b7280';
        span.textContent = 'No image available.';
        captchaContainer.appendChild(span);
      }
    }

    function renderLogs(values) {
      if (!latestLogEl) {
        return;
      }

      const rows = Array.isArray(values) ? values.slice(1) : [];
      let latestEntry = '';

      for (let i = rows.length - 1; i >= 0; i -= 1) {
        const row = rows[i];
        if (!row || row.length <= 4) {
          continue;
        }
        const text = String(row[4] ?? '').trim();
        if (text.length > 0) {
          latestEntry = text;
          break;
        }
      }

      if (latestEntry) {
        latestLogEl.textContent = latestEntry;
      } else {
        latestLogEl.textContent = 'No log entries yet.';
      }
    }

    function renderTable(values) {
      if (!sheetTableContainer) {
        return;
      }
      sheetTableContainer.innerHTML = '';
      if (!Array.isArray(values) || !values.length) {
        const empty = document.createElement('p');
        empty.style.margin = '0';
        empty.style.color = '#6b7280';
        empty.textContent = 'No data found in this sheet.';
        sheetTableContainer.appendChild(empty);
        return;
      }

      const table = document.createElement('table');
      const tbody = document.createElement('tbody');

      values.forEach((row) => {
        const tr = document.createElement('tr');
        row.forEach((cell) => {
          const td = document.createElement('td');
          td.textContent = cell ?? '';
          tr.appendChild(td);
        });
        if (!row.length) {
          const td = document.createElement('td');
          td.textContent = '';
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      sheetTableContainer.appendChild(table);
    }

    function normalizeStatus(value) {
      if (typeof value === 'string') {
        return value.trim().toUpperCase();
      }
      if (value == null) {
        return '';
      }
      return String(value).trim().toUpperCase();
    }

    function handleRunState(values) {
      const rawStatus = getCellValue(values, 'A2');
      const normalizedStatus = normalizeStatus(rawStatus);
      const statusChanged = normalizedStatus !== state.lastRunStatus;

      if (normalizedStatus === 'RUN') {
        updateStatusBadge('POLLING...', 'blue');
        stopPollingButton.classList.remove('hidden');
        state.lastRunStatus = normalizedStatus;
        return;
      }

      stopPolling();
      toggleRunning(false);

      if (statusChanged) {
        if (normalizedStatus === 'DONE' || normalizedStatus === 'ERROR') {
          // 🔸 Chỉ hiển thị popup nếu người dùng vừa nhấn RUN LOGIN
          if (state.running || state.lastRunStatus === 'RUN') {
            const type = normalizedStatus === 'DONE' ? 'success' : 'error';
            const message =
              normalizedStatus === 'DONE'
                ? 'Run completed successfully.'
                : 'Run finished with ERROR status.';
            setFeedback(type, message, { popup: true });
          } else {
            // 🔸 Nếu chỉ load trang hoặc đổi sheet thì chỉ log text, không popup
            const message =
              normalizedStatus === 'DONE'
                ? 'Run completed successfully.'
                : 'Run finished with ERROR status.';
            setFeedback(
              normalizedStatus === 'DONE' ? 'success' : 'error',
              message,
              { popup: false }
            );
          }
          updateStatusBadge(
            normalizedStatus === 'DONE' ? 'SUCCESS' : 'ERROR',
            normalizedStatus === 'DONE' ? 'green' : 'red'
          );
        } else if (normalizedStatus) {
          clearFeedback();
          updateStatusBadge(normalizedStatus, 'gray');
        } else {
          clearFeedback();
          updateStatusBadge('IDLE', 'gray');
        }
      } else if (normalizedStatus) {
        clearFeedback();
        updateStatusBadge(normalizedStatus, 'gray');
      } else {
        clearFeedback();
        updateStatusBadge('IDLE', 'gray');
      }

      // ✅ Cập nhật trạng thái sau khi xử lý
      state.lastRunStatus = normalizedStatus;
    }
    async function fetchSheetValues() {
      if (!state.sheetName) {
        setFeedback('info', 'Select a sheet to load data.');
        return [];
      }

      toggleLoading(true);
      try {
        const response = await fetch('/sheet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'get-state', sheetName: state.sheetName }),
        });
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(body.error || `Request failed (${response.status})`);
        }
        const data = await response.json();
        const values = data.values || data.state?.values || [];
        state.values = values;
        renderCaptcha(values);
        renderLogs(values);
        renderTable(values);
        handleRunState(values);
        return values;
      } finally {
        toggleLoading(false);
      }
    }

    function startPolling() {
      if (state.polling) {
        return;
      }
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }
      togglePolling(true);
      state.pollHandle = setInterval(() => {
        fetchSheetValues().catch((error) => {
          console.error('Failed to poll sheet:', error);
          setFeedback('error', error.message);
          stopPolling();
        });
      }, POLL_INTERVAL_MS);
      fetchSheetValues().catch((error) => {
        console.error('Failed to fetch sheet:', error);
        setFeedback('error', error.message);
        stopPolling();
      });
    }

    function stopPolling() {
      if (state.pollHandle) {
        clearInterval(state.pollHandle);
        state.pollHandle = null;
      }
      togglePolling(false);
    }

    async function updateCell(cell, value) {
      if (!state.sheetName) {
        throw new Error('Please select a sheet before updating.');
      }

      const response = await fetch('/sheet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'update-cell',
          cell,
          value,
          sheetName: state.sheetName,
        }),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(data.error || 'Failed to update cell.');
      }
      return data;
    }

    async function handleRunClick() {
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }

      clearFeedback();
      toggleRunning(true);
      try {
        await updateCell('A2', 'RUN');
        setFeedback('info', 'RUN LOGIN has been triggered.');
        startPolling();
      } catch (error) {
        console.error('RUN LOGIN failed:', error);
        setFeedback('error', error.message || 'RUN LOGIN failed.', { popup: true });
        stopPolling();
      } finally {
        toggleRunning(false);
      }
    }

    let submitting = false;

    function updateSubmitDisabled() {
      submitButton.disabled =
        submitting || !state.sheetName || captchaInput.value.length !== 3;
    }

    async function handleSubmitClick() {
      const trimmed = captchaInput.value.trim();
      if (trimmed.length !== 3) {
        setFeedback('error', 'Please enter exactly 3 digits before sending.');
        return;
      }

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before sending captcha.');
        return;
      }

      submitting = true;
      updateSubmitDisabled();
      clearFeedback();
      try {
        await updateCell('D2', trimmed);
        setFeedback('success', 'Captcha code saved to cell D2.');
        captchaInput.value = '';
        await fetchSheetValues();
      } catch (error) {
        console.error('Submit captcha failed:', error);
        setFeedback('error', error.message || 'Failed to submit captcha.');
      } finally {
        submitting = false;
        updateSubmitDisabled();
      }
    }

    async function handleStopPollingClick() {
      stopPolling();
      toggleRunning(false);

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before stopping.');
        return;
      }

      try {
        if (state.lastRunStatus === 'RUN') {
          await updateCell('A2', 'DONE');
          state.lastRunStatus = 'DONE';
          setFeedback('success', 'Status set to DONE.');
          await fetchSheetValues();
        } else {
          setFeedback('info', 'Polling stopped. Click RUN LOGIN to resume.');
        }
      } catch (error) {
        console.error('Stop polling update failed:', error);
        setFeedback('error', error.message || 'Failed to stop run.');
      }
    }

    runButton.addEventListener('click', handleRunClick);
    submitButton.addEventListener('click', handleSubmitClick);
    stopPollingButton.addEventListener('click', handleStopPollingClick);
    if (sheetSelector) {
      sheetSelector.addEventListener('change', (event) => {
        const value = event.target.value;
        setSheetName(value);
        stopPolling();
        toggleRunning(false);
        if (!value) {
          clearFeedback();
          return;
        }
        fetchSheetValues().catch((error) => {
          console.error('Sheet change fetch failed:', error);
          setFeedback('error', error.message || 'Failed to load sheet.');
        });
      });
    }

    if (feedbackCloseButton) {
      feedbackCloseButton.addEventListener('click', () => {
        clearFeedback();
      });
    }

    if (feedbackPopup) {
      feedbackPopup.addEventListener('click', (event) => {
        if (event.target === feedbackPopup) {
          clearFeedback();
        }
      });
    }

    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && feedbackPopup && feedbackPopup.classList.contains('visible')) {
        clearFeedback();
      }
    });
    if (refreshButton) {
      refreshButton.addEventListener('click', () => {
        fetchSheetValues().catch((error) => {
          console.error('Refresh failed:', error);
          setFeedback('error', error.message);
        });
      });
    }

    captchaInput.addEventListener('input', (event) => {
      const digitsOnly = restrictCaptchaInput(event.target.value);
      event.target.value = digitsOnly;
      updateSubmitDisabled();
    });

    window.addEventListener('focus', () => {
      if (state.polling) {
        fetchSheetValues().catch((error) => {
          console.error('Refresh on focus failed:', error);
        });
      }
    });

    window.addEventListener('beforeunload', () => {
      stopPolling();
    });

    // Initial load
    async function initializeDashboard() {
      updateSubmitDisabled();
      try {
        await fetchSheetList();
        if (state.sheetName) {
          await fetchSheetValues();
        }
      } catch (error) {
        console.error('Initialization failed:', error);
        if (!state.sheetName) {
          setFeedback('error', error.message || 'Initialization failed.');
        }
      }
    }

    initializeDashboard();
  </script>
</body>

</html>