<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Auto Login Dashboard</title>
  <style>
    :root {
      font-family: "Fira Code", "Cascadia Code", Consolas, "Courier New", monospace;
      color: #e2e8f0;
      background-color: #020617;
      --panel-bg: #0b1120;
      --panel-border: #1e293b;
      --panel-shadow: 0 24px 48px -32px rgba(2, 6, 23, 0.9);
      --accent: #38bdf8;
      --accent-strong: #22d3ee;
      --accent-alt: #8b5cf6;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --danger: #f43f5e;
      --success: #22c55e;
      --warning: #fbbf24;
      --app-vh: 100vh;
    }

    * {
      box-sizing: border-box;
      font-family: inherit;
    }

    *::before,
    *::after {
      box-sizing: inherit;
    }

    html,
    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      min-height: var(--app-vh);
      background: radial-gradient(circle at 12% 18%, rgba(59, 130, 246, 0.18), transparent 55%),
        radial-gradient(circle at 82% 12%, rgba(126, 58, 242, 0.2), transparent 50%),
        radial-gradient(circle at 50% 80%, rgba(14, 165, 233, 0.12), transparent 60%),
        #020617;
      color: var(--text);
      font-family: "Fira Code", "Cascadia Code", Consolas, "Courier New", monospace;
      overflow-x: hidden;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: clamp(1.25rem, 3vw, 2.5rem);
      background-attachment: fixed;
    }

    main {
      width: min(1080px, 100%);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: clamp(0.75rem, 2vw, 1.25rem);
    }

    main>.panel:first-of-type,
    main>.panel:nth-of-type(2) {
      grid-column: 1 / -1;
    }

    h1,
    h2 {
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text);
    }

    h1 {
      font-size: clamp(2rem, 4vw, 2.6rem);
    }

    h2 {
      font-size: clamp(1.1rem, 3vw, 1.4rem);
    }

    .panel {
      background: linear-gradient(165deg, rgba(15, 23, 42, 0.55), rgba(2, 6, 23, 0.35));
      border: 1px solid rgba(56, 189, 248, 0.24);
      box-shadow:
        0 28px 60px -32px rgba(2, 6, 23, 0.88),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 0 0 1px rgba(148, 163, 184, 0.08);
      border-radius: 14px;
      padding: clamp(1.15rem, 2.6vw, 1.6rem);
      display: flex;
      flex-direction: column;
      gap: 1.05rem;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(28px) saturate(155%);
      -webkit-backdrop-filter: blur(28px) saturate(155%);
      transition: transform 0.35s ease, box-shadow 0.35s ease, border-color 0.35s ease;
    }

    .panel::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        linear-gradient(115deg, rgba(56, 189, 248, 0.18), transparent 60%),
        linear-gradient(250deg, rgba(8, 47, 73, 0.16), transparent 55%);
      opacity: 0.95;
      pointer-events: none;
    }

    .panel::after {
      content: '';
      position: absolute;
      inset: 1px;
      border-radius: 12px;
      background:
        radial-gradient(circle at top, rgba(148, 163, 184, 0.18), transparent 55%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent 65%);
      opacity: 0.95;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .panel:hover,
    .panel:focus-within {
      transform: translateY(-6px);
      border-color: rgba(56, 189, 248, 0.42);
      box-shadow:
        0 32px 64px -28px rgba(8, 47, 73, 0.95),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 0 0 1px rgba(148, 163, 184, 0.14);
    }

    .panel>* {
      position: relative;
      z-index: 1;
    }

    .panel header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .panel-status {
      transition: border-color 0.35s ease, box-shadow 0.35s ease;
    }

    .panel-status.status-gray {
      border-color: rgba(148, 163, 184, 0.55);
      box-shadow:
        0 18px 38px -28px rgba(15, 23, 42, 0.9),
        inset 0 0 0 2px rgba(148, 163, 184, 0.18),
        inset 0 0 24px rgba(148, 163, 184, 0.18);
    }

    .panel-status.status-blue {
      border-color: rgba(37, 99, 235, 0.85);
      box-shadow:
        0 22px 48px -28px rgba(37, 99, 235, 0.65),
        inset 0 0 0 2px rgba(96, 165, 250, 0.45),
        inset 0 0 36px rgba(59, 130, 246, 0.45);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.28), transparent 55%), rgba(15, 23, 42, 0.4);
    }

    .panel-status.status-green {
      border-color: rgba(22, 163, 74, 0.9);
      box-shadow:
        0 22px 48px -28px rgba(22, 163, 74, 0.65),
        inset 0 0 0 2px rgba(74, 222, 128, 0.42),
        inset 0 0 36px rgba(34, 197, 94, 0.4);
      background: linear-gradient(160deg, rgba(34, 197, 94, 0.26), transparent 55%), rgba(15, 23, 42, 0.4);
    }

    .panel-status.status-red {
      border-color: rgba(239, 68, 68, 0.85);
      box-shadow:
        0 22px 48px -28px rgba(239, 68, 68, 0.6),
        inset 0 0 0 2px rgba(248, 113, 113, 0.42),
        inset 0 0 36px rgba(248, 113, 113, 0.4);
      background: linear-gradient(160deg, rgba(248, 113, 113, 0.26), transparent 55%), rgba(15, 23, 42, 0.4);
    }

    .panel-status.status-amber {
      border-color: rgba(250, 204, 21, 0.85);
      box-shadow:
        0 22px 48px -28px rgba(250, 204, 21, 0.58),
        inset 0 0 0 2px rgba(250, 204, 21, 0.42),
        inset 0 0 36px rgba(250, 204, 21, 0.38);
      background: linear-gradient(160deg, rgba(250, 204, 21, 0.24), transparent 55%), rgba(15, 23, 42, 0.4);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.3rem 0.75rem;
      border-radius: 3px;
      font-size: 0.7rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.85), rgba(56, 189, 248, 0.75));
      color: #0f172a;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.6);
    }

    .status-badge.blue {
      background: linear-gradient(90deg, rgba(96, 165, 250, 0.9), rgba(14, 165, 233, 0.85));
      color: #020617;
    }

    .status-badge.green {
      background: linear-gradient(90deg, rgba(74, 222, 128, 0.9), rgba(34, 197, 94, 0.85));
      color: #041907;
    }

    .status-badge.gray {
      background: linear-gradient(90deg, rgba(100, 116, 139, 0.85), rgba(71, 85, 105, 0.85));
      color: #e2e8f0;
    }

    .status-badge.red {
      background: linear-gradient(90deg, rgba(248, 113, 113, 0.9), rgba(244, 63, 94, 0.85));
      color: #ffffff;
    }

    .status-badge.amber {
      background: linear-gradient(90deg, rgba(251, 191, 36, 0.9), rgba(250, 204, 21, 0.85));
      color: #1f1305;
    }

    .sheet-selector {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .sheet-selector label {
      font-size: 0.85rem;
      color: var(--muted);
      letter-spacing: 0.08em;
    }

    .sheet-selector select {
      appearance: none;
      background: #010b1a;
      border: 1px solid #1e293b;
      color: var(--text);
      padding: 0.6rem 0.75rem;
      border-radius: 4px;
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .sheet-selector select:hover:not(:disabled),
    .sheet-selector select:focus-visible {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.25);
      outline: none;
    }

    .sheet-selector select:disabled {
      border-color: #111827;
      color: #475569;
      background: #0f172a;
      cursor: not-allowed;
    }

    button {
      cursor: pointer;
      border: 1px solid #1f2937;
      border-radius: 4px;
      padding: 0.7rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: linear-gradient(90deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
      color: var(--text);
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    button:hover:not(:disabled) {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
      transform: translateY(-2px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    button:focus-visible {
      outline: none;
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.35);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.primary {
      border-color: rgba(59, 130, 246, 0.6);
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.18), rgba(56, 189, 248, 0.18));
    }

    button.secondary {
      border-color: #334155;
      background: linear-gradient(90deg, rgba(15, 23, 42, 0.75), rgba(17, 24, 39, 0.75));
    }

    button.is-locked {
      border-style: dashed;
      color: rgba(148, 163, 184, 0.7);
    }

    .captcha-area {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(0.45rem, 2vw, 0.7rem);
      width: 100%;
      flex-wrap: nowrap;
    }

    .captcha-area input {
      flex: 1 1 auto;
      min-width: 140px;
      padding: clamp(0.5rem, 1.8vw, 0.7rem);
      font-size: clamp(1rem, 3.2vw, 1.2rem);
      text-align: center;
      letter-spacing: clamp(0.18rem, 1.6vw, 0.3rem);
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: #010b1a;
      color: var(--text);
      box-shadow: inset 0 0 12px rgba(8, 145, 178, 0.12);
      caret-color: var(--accent);
    }

    .captcha-area input::placeholder {
      color: rgba(148, 163, 184, 0.5);
    }

    .captcha-area input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.3);
    }

    .captcha-area button {
      flex: 0 0 clamp(92px, 22vw, 130px);
      padding: clamp(0.5rem, 2vw, 0.7rem) clamp(0.75rem, 3vw, 0.95rem);
      white-space: nowrap;
    }

    .image-box {
      border: 1px solid #1f2937;
      background: #0b1120;
      border-radius: 4px;
      padding: clamp(0.75rem, 2vw, 1rem);
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.3s ease;
    }

    .image-box.has-image {
      padding: clamp(0.5rem, 2vw, 0.75rem);
      background: #010b1a;
    }

    .image-box.empty span {
      color: var(--muted);
    }

    .image-box img {
      max-width: 100%;
      height: auto;
      border-radius: 2px;
      filter: drop-shadow(0 12px 24px rgba(8, 145, 178, 0.25));
    }

    .latest-log {
      padding: 0.9rem 1rem;
      border: 1px solid #1f2937;
      border-radius: 4px;
      background: #0b1120;
      color: var(--text);
      min-height: 100px;
      letter-spacing: 0.03em;
      line-height: 1.45;
    }

    .sheet-preview table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #1e293b;
      background: #010b1a;
      color: var(--text);
    }

    .sheet-preview th,
    .sheet-preview td {
      border: 1px solid #1e293b;
      padding: 0.65rem;
      font-size: 0.85rem;
    }

    .sheet-preview th {
      background: rgba(15, 23, 42, 0.75);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .sheet-preview tr:nth-child(even) td {
      background: rgba(15, 23, 42, 0.55);
    }

    .feedback-popup {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1rem, 4vw, 2rem);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.25s ease, visibility 0.25s ease;
    }

    .feedback-popup.visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .feedback-popup__content {
      width: min(380px, 100%);
      background: #010b1a;
      border: 1px solid #1f2937;
      border-radius: 4px;
      padding: clamp(1rem, 3vw, 1.4rem);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      box-shadow: 0 14px 40px -20px rgba(15, 23, 42, 0.85);
    }

    .feedback-popup__message {
      color: var(--text);
    }

    .feedback-popup__actions {
      display: flex;
      justify-content: flex-end;
    }

    .feedback-popup__close {
      border: 1px solid #38bdf8;
      background: linear-gradient(90deg, rgba(56, 189, 248, 0.2), rgba(59, 130, 246, 0.2));
      color: var(--text);
      border-radius: 3px;
      padding: 0.55rem 0.85rem;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 768px) {
      body {
        padding: clamp(1rem, 4vw, 1.75rem);
      }

      main {
        grid-template-columns: 1fr;
      }

      .captcha-area button {
        flex-basis: clamp(88px, 28vw, 120px);
      }
    }

    @media (max-width: 480px) {
      body {
        padding: clamp(0.85rem, 5vw, 1.25rem);
      }

      .panel {
        padding: 1rem;
      }

      .captcha-area input {
        font-size: 0.95rem;
        letter-spacing: 0.2rem;
      }

      .captcha-area button {
        padding: 0.55rem 0.75rem;
      }
    }

    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>

<body>
  <div id="feedback" class="feedback-popup hidden">
    <div class="feedback-popup__content">
      <div id="feedbackMessage" class="feedback-popup__message"></div>
      <div class="feedback-popup__actions">
        <button type="button" id="feedbackClose" class="feedback-popup__close">
          Close
        </button>
      </div>
    </div>
  </div>
  <main>
    <section id="statusPanel" class="panel panel-status status-gray">
      <header>
        <h1>Auto Login</h1>
        <span id="pollingBadge" class="status-badge gray hidden">Idle</span>
      </header>
    </section>

    <section class="panel">
      <h2>Log</h2>
      <div id="latestLog" class="latest-log">
        No log entries yet.
      </div>
    </section>

    <section class="panel">
      <header>
        <h2>Control Panel</h2>
        <span id="runningBadge" class="status-badge blue hidden">Running...</span>
      </header>
      <div class="sheet-selector">
        <label for="sheetSelector">Sheet</label>
        <select id="sheetSelector" disabled>
          <option>Loading...</option>
        </select>
      </div>
      <button id="runButton" class="primary">
        <span id="runButtonText">RUN LOGIN</span>
      </button>
      <button id="stopPollingButton" class="secondary hidden">
        Stop Polling
      </button>
    </section>

    <section class="panel">
      <h2>Captcha Image</h2>
      <div class="sheet-selector">
        <label for="sheetSelector">Image</label>
      </div>
      <div class="image-box empty" id="captchaContainer">
        <span>No image available.</span>
      </div>
      <div class="sheet-selector">
        <label for="sheetSelector">Enter</label>
      </div>
      <div class="captcha-area">
        <input id="captchaInput" type="text" placeholder="000" inputmode="numeric" maxlength="3"
          aria-label="Captcha answer (3 digits)" />
        <button id="submitButton" class="secondary">Send</button>
      </div>
    </section>
  </main>

  <script>
    const POLL_INTERVAL_MS = 2000;
    const state = {
      loading: false,
      polling: false,
      running: false,
      pollHandle: null,
      values: [],
      lastRunStatus: '',
      sheetName: '',
      sheets: [],
    };

    const runButton = document.getElementById('runButton');
    const runButtonText = document.getElementById('runButtonText');
    const stopPollingButton = document.getElementById('stopPollingButton');
    const sheetSelector = document.getElementById('sheetSelector');
    const submitButton = document.getElementById('submitButton');
    const captchaInput = document.getElementById('captchaInput');
    const feedbackPopup = document.getElementById('feedback');
    const feedbackMessageEl = document.getElementById('feedbackMessage');
    const feedbackCloseButton = document.getElementById('feedbackClose');
    const captchaContainer = document.getElementById('captchaContainer');
    const latestLogEl = document.getElementById('latestLog');
    const sheetTableContainer = document.getElementById(
      'sheetTableContainer'
    );
    const refreshButton = document.getElementById('refreshButton');
    const runningBadge = document.getElementById('runningBadge');
    const pollingBadge = document.getElementById('pollingBadge');
    const statusPanel = document.getElementById('statusPanel');
    const loadingBadge = document.getElementById('loadingBadge');
    const rootElement = document.documentElement;
    let baseViewportHeight =
      Math.max(window.innerHeight || 0, window.visualViewport ? window.visualViewport.height : 0) || 0;
    let keyboardActive = false;

    const FEEDBACK_TYPES = ['success', 'error', 'info'];
    const STATUS_BADGE_VARIANTS = ['gray', 'green', 'blue', 'red', 'amber'];

    function updateViewportHeight(options = {}) {
      const { force = false } = options;
      const viewport = window.visualViewport;
      const height = viewport ? viewport.height : window.innerHeight;
      if (!height) {
        return;
      }

      if (!baseViewportHeight) {
        baseViewportHeight = height;
      }

      if (!force) {
        if (keyboardActive) {
          return;
        }
        if (baseViewportHeight && height < baseViewportHeight - 80) {
          return;
        }
      }

      if (!keyboardActive || force) {
        baseViewportHeight = Math.max(baseViewportHeight, height);
      }

      const targetHeight = force ? baseViewportHeight : Math.max(height, baseViewportHeight);
      rootElement.style.setProperty('--app-vh', `${targetHeight}px`);
    }

    updateViewportHeight({ force: true });

    const detachViewportListeners = (() => {
      const viewportHandler = () => updateViewportHeight();
      const orientationHandler = () => updateViewportHeight({ force: true });
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', viewportHandler);
        window.visualViewport.addEventListener('scroll', viewportHandler);
      } else {
        window.addEventListener('resize', viewportHandler);
      }
      window.addEventListener('orientationchange', orientationHandler);
      return () => {
        if (window.visualViewport) {
          window.visualViewport.removeEventListener('resize', viewportHandler);
          window.visualViewport.removeEventListener('scroll', viewportHandler);
        } else {
          window.removeEventListener('resize', viewportHandler);
        }
        window.removeEventListener('orientationchange', orientationHandler);
      };
    })();

    document.addEventListener('focusin', (event) => {
      const target = event.target;
      if (target instanceof HTMLElement && target.matches('input, textarea, select, [contenteditable="true"]')) {
        keyboardActive = true;
        rootElement.classList.add('keyboard-active');
      }
    });

    document.addEventListener('focusout', (event) => {
      const target = event.target;
      if (target instanceof HTMLElement && target.matches('input, textarea, select, [contenteditable="true"]')) {
        keyboardActive = false;
        rootElement.classList.remove('keyboard-active');
        setTimeout(() => {
          document.body.scrollIntoView({ block: 'start', behavior: 'smooth' });
          updateViewportHeight({ force: true });
        }, 120);
      }
    });

    function resolveStatusVariant(status) {
      switch (status) {
        case 'RUN':
          return 'blue';
        case 'DONE':
          return 'green';
        case 'ERROR':
          return 'red';
        case 'PENDING':
          return 'amber';
        default:
          return 'gray';
      }
    }

    function refreshRunButtonState() {
      if (!runButton) {
        return;
      }
      const normalized = normalizeStatus(state.lastRunStatus);
      const isPending = normalized === 'PENDING';
      const isRunningStatus = normalized === 'RUN';
      const shouldDisable =
        state.running || !state.sheetName || isPending || isRunningStatus;
      runButton.disabled = shouldDisable;
      runButton.classList.toggle('is-locked', isPending || isRunningStatus);

      if (isPending) {
        runButton.title = 'Status is PENDING. Please wait until it changes.';
      } else if (isRunningStatus) {
        runButton.title = 'Status is RUN. Please wait for completion.';
      } else if (state.running) {
        runButton.title = 'Request already in progress.';
      } else if (!state.sheetName) {
        runButton.title = 'Select a sheet to start.';
      } else {
        runButton.removeAttribute('title');
      }
    }

    function updateActionButtons() {
      if (!runButton || !stopPollingButton) {
        return;
      }
      const showStop =
        state.running ||
        state.polling ||
        normalizeStatus(state.lastRunStatus) === 'RUN';
      runButton.classList.toggle('hidden', showStop);
      stopPollingButton.classList.toggle('hidden', !showStop);
    }

    function setFeedback(type, message) {
      if (!message || typeof message !== 'string' || !message.trim()) {
        clearFeedback();
        return;
      }

      clearFeedback();
      if (latestLogEl && message) {
        latestLogEl.textContent = message;
      }
    }

    function clearFeedback() {
      if (!feedbackPopup || !feedbackMessageEl) {
        return;
      }

      FEEDBACK_TYPES.forEach((t) =>
        feedbackPopup.classList.remove(`is-${t}`)
      );
      feedbackPopup.classList.remove('visible');
      feedbackPopup.classList.add('hidden');
      feedbackMessageEl.textContent = '';
    }

    function setStatusPanelVariant(variant) {
      if (!statusPanel) {
        return;
      }
      const applied = STATUS_BADGE_VARIANTS.includes(variant)
        ? variant
        : 'gray';
      STATUS_BADGE_VARIANTS.forEach((color) => {
        statusPanel.classList.toggle(`status-${color}`, color === applied);
      });
    }

    function updateStatusBadge(label, variant = 'gray') {
      if (!pollingBadge) {
        return;
      }
      const safeLabel =
        typeof label === 'string' && label.trim()
          ? label.trim()
          : 'IDLE';
      pollingBadge.textContent = safeLabel;
      STATUS_BADGE_VARIANTS.forEach((color) => {
        pollingBadge.classList.toggle(color, color === variant);
      });
      pollingBadge.classList.remove('hidden');
      setStatusPanelVariant(variant);
    }

    function setSheetName(name) {
      const normalized = typeof name === 'string' ? name : '';
      state.sheetName = normalized;
      if (sheetSelector) {
        sheetSelector.value = normalized;
      }
      state.lastRunStatus = '';
      refreshRunButtonState();
      updateActionButtons();
      updateSubmitDisabled();
    }

    function renderSheetOptions(options) {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.innerHTML = '';
      const fragment = document.createDocumentFragment();

      // ?? Thêm placeholder tr?ng làm m?c d?nh
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select sheet';
      placeholder.disabled = true;
      placeholder.selected = true;
      fragment.appendChild(placeholder);

      // ?? Thêm danh sách các sheet th?t s?
      options.forEach((sheet) => {
        const option = document.createElement('option');
        option.value = sheet.title;
        option.textContent = sheet.title;
        if (sheet.id !== null && sheet.id !== undefined) {
          option.dataset.sheetId = String(sheet.id);
        }
        fragment.appendChild(option);
      });

      sheetSelector.appendChild(fragment);

      // ?? Không ch?n sheet m?c d?nh nào h?t
      setSheetName('');
      sheetSelector.value = '';

      // ?? Tr?ng thái hi?n th? v?n là “IDLE”
      updateStatusBadge('IDLE', 'gray');
      sheetSelector.disabled = false;
    }

    async function fetchSheetList() {
      if (!sheetSelector) {
        return;
      }

      sheetSelector.disabled = true;
      sheetSelector.innerHTML = '<option>Loading...</option>';

      try {
        const response = await fetch('/sheets');
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(
            body.error || `Request failed (${response.status})`
          );
        }

        const data = await response.json();
        const sheets = Array.isArray(data.sheets) ? data.sheets : [];
        const defaultSheet = data.defaultSheet;

        state.sheets = sheets;

        if (!sheets.length) {
          sheetSelector.innerHTML =
            '<option value=\"\">No sheets found</option>';
          setSheetName('');
          updateStatusBadge('IDLE', 'gray');
          setFeedback('error', 'No sheets available in this spreadsheet.');
          return;
        }

        renderSheetOptions(sheets, defaultSheet);
      } catch (error) {
        console.error('Failed to fetch sheet list:', error);
        sheetSelector.innerHTML = '<option value=\"\">Load failed</option>';
        setSheetName('');
        updateStatusBadge('IDLE', 'gray');
        state.sheets = [];
        setFeedback('error', error.message || 'Failed to load sheet list.');
        throw error;
      } finally {
        sheetSelector.disabled = state.sheets.length === 0;
      }
    }

    function toggleRunning(isRunning) {
      state.running = isRunning;
      refreshRunButtonState();
      runningBadge.classList.toggle('hidden', !isRunning);
      runButtonText.textContent = isRunning ? 'Sending...' : 'RUN LOGIN';
      updateActionButtons();
    }

    function togglePolling(isPolling) {
      state.polling = isPolling;
      if (!isPolling && (!state.lastRunStatus || state.lastRunStatus === 'RUN')) {
        updateStatusBadge('IDLE', 'gray');
      }
      updateActionButtons();
    }

    function toggleLoading(isLoading) {
      state.loading = isLoading;
      if (loadingBadge) {
        loadingBadge.classList.toggle('hidden', !isLoading);
      }
    }

    function restrictCaptchaInput(value) {
      return value.replace(/\D/g, '').slice(0, 3);
    }

    function getCellValue(values, cellLabel) {
      if (!cellLabel) {
        return '';
      }
      const match = /^([A-Za-z]+)(\d+)$/.exec(cellLabel);
      if (!match) {
        return '';
      }
      const [, letters, rowStr] = match;
      const rowIndex = parseInt(rowStr, 10) - 1;
      if (Number.isNaN(rowIndex) || rowIndex < 0) {
        return '';
      }
      let colIndex = 0;
      for (let i = 0; i < letters.length; i += 1) {
        colIndex *= 26;
        colIndex += letters.toUpperCase().charCodeAt(i) - 64;
      }
      colIndex -= 1;
      if (!values[rowIndex]) {
        return '';
      }
      return values[rowIndex][colIndex] ?? '';
    }

    function resolveImageSource(raw) {
      if (!raw) {
        return null;
      }
      const trimmed = String(raw).trim();
      if (!trimmed) {
        return null;
      }

      const noWhitespace = trimmed.replace(/\s+/g, '');
      const sanitized = noWhitespace.replace(/^["']+|["']+$/g, '');
      if (!sanitized) {
        return null;
      }

      if (
        sanitized.startsWith('http://') ||
        sanitized.startsWith('https://') ||
        sanitized.startsWith('data:')
      ) {
        return sanitized;
      }

      const base64Candidate = sanitized.startsWith('base64,')
        ? sanitized.substring('base64,'.length)
        : sanitized;

      const padding = base64Candidate.length % 4;
      const padded =
        padding === 0
          ? base64Candidate
          : `${base64Candidate}${'='.repeat(4 - padding)}`;

      try {
        if (typeof window !== 'undefined' && typeof window.atob === 'function') {
          window.atob(padded);
        }
        return `data:image/png;base64,${padded}`;
      } catch (error) {
        console.warn('Invalid base64 captcha image', error);
        return null;
      }
    }

    function renderCaptcha(values) {
      let rawImage = getCellValue(values, 'C2');
      let source = resolveImageSource(rawImage);
      if (!source) {
        rawImage = getCellValue(values, 'B2');
        source = resolveImageSource(rawImage);
      }
      captchaContainer.innerHTML = '';
      captchaContainer.classList.remove('has-image', 'empty');
      captchaContainer.style.removeProperty('width');
      captchaContainer.style.removeProperty('height');
      if (source) {
        const img = document.createElement('img');
        img.src = source;
        img.alt = 'Captcha from Google Sheet';
        captchaContainer.classList.add('has-image');
        captchaContainer.appendChild(img);
      } else {
        const span = document.createElement('span');
        span.textContent = 'No image available.';
        captchaContainer.classList.add('empty');
        captchaContainer.appendChild(span);
      }
    }

    function renderLogs(values) {
      if (!latestLogEl) {
        return;
      }

      const rows = Array.isArray(values) ? values.slice(1) : [];
      let latestEntry = '';

      for (let i = rows.length - 1; i >= 0; i -= 1) {
        const row = rows[i];
        if (!row || row.length <= 4) {
          continue;
        }
        const text = String(row[4] ?? '').trim();
        if (text.length > 0) {
          latestEntry = text;
          break;
        }
      }

      if (latestEntry) {
        latestLogEl.textContent = latestEntry;
      } else {
        latestLogEl.textContent = 'No log entries yet.';
      }
    }

    function renderTable(values) {
      if (!sheetTableContainer) {
        return;
      }
      sheetTableContainer.innerHTML = '';
      if (!Array.isArray(values) || !values.length) {
        const empty = document.createElement('p');
        empty.style.margin = '0';
        empty.style.color = '#6b7280';
        empty.textContent = 'No data found in this sheet.';
        sheetTableContainer.appendChild(empty);
        return;
      }

      const table = document.createElement('table');
      const tbody = document.createElement('tbody');

      values.forEach((row) => {
        const tr = document.createElement('tr');
        row.forEach((cell) => {
          const td = document.createElement('td');
          td.textContent = cell ?? '';
          tr.appendChild(td);
        });
        if (!row.length) {
          const td = document.createElement('td');
          td.textContent = '';
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      sheetTableContainer.appendChild(table);
    }

    function normalizeStatus(value) {
      if (typeof value === 'string') {
        return value.trim().toUpperCase();
      }
      if (value == null) {
        return '';
      }
      return String(value).trim().toUpperCase();
    }

    function handleRunState(values) {
      const rawStatus = getCellValue(values, 'A2');
      const normalizedStatus = normalizeStatus(rawStatus);
      const statusChanged = normalizedStatus !== state.lastRunStatus;
      const variant = resolveStatusVariant(normalizedStatus);

      if (normalizedStatus === 'RUN') {
        updateStatusBadge(normalizedStatus || 'RUN', variant);
        stopPollingButton.classList.remove('hidden');
        state.lastRunStatus = normalizedStatus;
        refreshRunButtonState();
        updateActionButtons();
        return;
      }

      stopPolling();
      toggleRunning(false);

      if (statusChanged) {
        if (normalizedStatus === 'DONE' || normalizedStatus === 'ERROR') {
          const message =
            normalizedStatus === 'DONE'
              ? 'Run completed successfully.'
              : 'Run finished with ERROR status.';
          const feedbackType =
            normalizedStatus === 'DONE' ? 'success' : 'error';

          setFeedback(feedbackType, message);
        } else {
          clearFeedback();
        }
      } else if (!normalizedStatus) {
        clearFeedback();
      }

      const label = normalizedStatus || 'IDLE';
      const badgeVariant = normalizedStatus ? variant : 'gray';
      updateStatusBadge(label, badgeVariant);

      state.lastRunStatus = normalizedStatus;
      refreshRunButtonState();
      updateActionButtons();
    }
    async function fetchSheetValues() {
      if (!state.sheetName) {
        setFeedback('info', 'Select a sheet to load data.');
        return [];
      }

      toggleLoading(true);
      try {
        const response = await fetch('/sheet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'get-state', sheetName: state.sheetName }),
        });
        if (!response.ok) {
          const body = await response.json().catch(() => ({}));
          throw new Error(body.error || `Request failed (${response.status})`);
        }
        const data = await response.json();
        const values = data.values || data.state?.values || [];
        state.values = values;
        renderCaptcha(values);
        renderLogs(values);
        renderTable(values);
        handleRunState(values);
        return values;
      } finally {
        toggleLoading(false);
      }
    }

    function startPolling() {
      if (state.polling) {
        return;
      }
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }
      togglePolling(true);
      state.pollHandle = setInterval(() => {
        fetchSheetValues().catch((error) => {
          console.error('Failed to poll sheet:', error);
          setFeedback('error', error.message);
          stopPolling();
        });
      }, POLL_INTERVAL_MS);
      fetchSheetValues().catch((error) => {
        console.error('Failed to fetch sheet:', error);
        setFeedback('error', error.message);
        stopPolling();
      });
    }

    function stopPolling() {
      if (state.pollHandle) {
        clearInterval(state.pollHandle);
        state.pollHandle = null;
      }
      togglePolling(false);
    }

    async function updateCell(cell, value) {
      if (!state.sheetName) {
        throw new Error('Please select a sheet before updating.');
      }

      const response = await fetch('/sheet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'update-cell',
          cell,
          value,
          sheetName: state.sheetName,
        }),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(data.error || 'Failed to update cell.');
      }
      return data;
    }

    async function handleRunClick() {
      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before running.');
        return;
      }

      clearFeedback();
      toggleRunning(true);
      try {
        await updateCell('A2', 'RUN');
        setFeedback('info', 'RUN LOGIN has been triggered.');
        startPolling();
      } catch (error) {
        console.error('RUN LOGIN failed:', error);
        setFeedback('error', error.message || 'RUN LOGIN failed.');
        stopPolling();
      } finally {
        toggleRunning(false);
      }
    }

    let submitting = false;

    function updateSubmitDisabled() {
      submitButton.disabled =
        submitting || !state.sheetName || captchaInput.value.length !== 3;
    }

    async function handleSubmitClick() {
      const trimmed = captchaInput.value.trim();
      if (trimmed.length !== 3) {
        setFeedback('error', 'Please enter exactly 3 digits before sending.');
        return;
      }

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before sending captcha.');
        return;
      }

      submitting = true;
      updateSubmitDisabled();
      clearFeedback();
      try {
        await updateCell('D2', trimmed);
        setFeedback('success', 'Captcha code saved to cell D2.');
        captchaInput.value = '';
        await fetchSheetValues();
      } catch (error) {
        console.error('Submit captcha failed:', error);
        setFeedback('error', error.message || 'Failed to submit captcha.');
      } finally {
        submitting = false;
        updateSubmitDisabled();
      }
    }

    async function handleStopPollingClick() {
      stopPolling();
      toggleRunning(false);

      if (!state.sheetName) {
        setFeedback('error', 'Select a sheet before stopping.');
        return;
      }

      try {
        if (state.lastRunStatus === 'RUN') {
          await updateCell('A2', 'DONE');
          state.lastRunStatus = 'DONE';
          setFeedback('success', 'Status set to DONE.');
          await fetchSheetValues();
        } else {
          setFeedback('info', 'Polling stopped. Click RUN LOGIN to resume.');
        }
      } catch (error) {
        console.error('Stop polling update failed:', error);
        setFeedback('error', error.message || 'Failed to stop run.');
      }
    }

    runButton.addEventListener('click', handleRunClick);
    submitButton.addEventListener('click', handleSubmitClick);
    stopPollingButton.addEventListener('click', handleStopPollingClick);
    if (sheetSelector) {
      sheetSelector.addEventListener('change', (event) => {
        const value = event.target.value;
        setSheetName(value);
        stopPolling();
        toggleRunning(false);
        if (!value) {
          clearFeedback();
          return;
        }
        fetchSheetValues().catch((error) => {
          console.error('Sheet change fetch failed:', error);
          setFeedback('error', error.message || 'Failed to load sheet.');
        });
      });
    }

    if (feedbackCloseButton) {
      feedbackCloseButton.addEventListener('click', () => {
        clearFeedback();
      });
    }

    if (feedbackPopup) {
      feedbackPopup.addEventListener('click', (event) => {
        if (event.target === feedbackPopup) {
          clearFeedback();
        }
      });
    }

    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && feedbackPopup && feedbackPopup.classList.contains('visible')) {
        clearFeedback();
      }
    });
    if (refreshButton) {
      refreshButton.addEventListener('click', () => {
        fetchSheetValues().catch((error) => {
          console.error('Refresh failed:', error);
          setFeedback('error', error.message);
        });
      });
    }

    captchaInput.addEventListener('input', (event) => {
      const digitsOnly = restrictCaptchaInput(event.target.value);
      event.target.value = digitsOnly;
      updateSubmitDisabled();
    });

    window.addEventListener('focus', () => {
      if (state.polling) {
        fetchSheetValues().catch((error) => {
          console.error('Refresh on focus failed:', error);
        });
      }
    });

    window.addEventListener('beforeunload', () => {
      stopPolling();
      if (typeof detachViewportListeners === 'function') {
        detachViewportListeners();
      }
    });

    // Initial load
    async function initializeDashboard() {
      updateSubmitDisabled();
      refreshRunButtonState();
      updateActionButtons();
      try {
        await fetchSheetList();
        if (state.sheetName) {
          await fetchSheetValues();
        }
      } catch (error) {
        console.error('Initialization failed:', error);
        if (!state.sheetName) {
          setFeedback('error', error.message || 'Initialization failed.');
        }
      }
    }

    initializeDashboard();
  </script>
</body>

</html>