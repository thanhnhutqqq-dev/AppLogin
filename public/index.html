<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Auto Login Dashboard</title>
    <style>
      :root {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: #1f2933;
        background-color: #f5f7fa;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        display: flex;
        justify-content: center;
        padding: 2.5rem 1.5rem;
      }

      main {
        width: min(960px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      h1 {
        margin: 0;
        font-size: 2rem;
        font-weight: 600;
      }

      h2 {
        margin: 0;
        font-size: 1.25rem;
        font-weight: 600;
      }

      .panel {
        background-color: #fff;
        border: 1px solid #d2d6dc;
        border-radius: 10px;
        padding: 1.5rem;
        box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .panel header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .status-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .status-badge.blue {
        background-color: #dbeafe;
        color: #1d4ed8;
      }

      .status-badge.green {
        background-color: #dcfce7;
        color: #15803d;
      }

      .status-badge.gray {
        background-color: #e5e7eb;
        color: #4b5563;
      }

      .status-badge.red {
        background-color: #fee2e2;
        color: #b91c1c;
      }

      button {
        cursor: pointer;
        border: none;
        border-radius: 8px;
        padding: 0.8rem 1rem;
        font-size: 1rem;
        font-weight: 600;
        transition: background-color 0.2s ease, transform 0.15s ease;
      }

      button.primary {
        background-color: #2563eb;
        color: #fff;
      }

      button.primary:hover:not(:disabled) {
        background-color: #1e4ed8;
      }

      button.primary:active:not(:disabled) {
        transform: translateY(1px);
      }

      button.secondary {
        background-color: #e5edff;
        color: #1f3a8a;
        border: 1px solid #c3d4ff;
      }

      button.secondary:hover:not(:disabled) {
        background-color: #d0dcff;
      }

      button:disabled {
        background-color: #93c5fd;
        cursor: not-allowed;
        transform: none;
      }

      .feedback {
        border-radius: 10px;
        padding: 1rem 1.25rem;
        font-weight: 500;
        border: 1px solid transparent;
      }

      .feedback.success {
        background-color: #dcfce7;
        color: #166534;
        border-color: #bbf7d0;
      }

      .feedback.error {
        background-color: #fee2e2;
        color: #b91c1c;
        border-color: #fecaca;
      }

      .feedback.info {
        background-color: #e0f2fe;
        color: #0c4a6e;
        border-color: #bae6fd;
      }

      .captcha-area {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .captcha-area input {
        flex: 1;
        min-width: 140px;
        padding: 0.75rem;
        font-size: 1.25rem;
        font-weight: 600;
        text-align: center;
        border-radius: 8px;
        border: 1px solid #cbd5e1;
        letter-spacing: 0.4rem;
      }

      .captcha-area input:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }

      .image-box {
        border: 1px dashed #cbd5e1;
        background-color: #f8fafc;
        border-radius: 8px;
        padding: 0.5rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        max-width: 100%;
        align-self: center;
      }

      .image-box img {
        display: block;
        max-width: 100%;
        height: auto;
        object-fit: contain;
      }

      .logs {
        border-radius: 8px;
        border: 1px solid #d2d6dc;
        background-color: #f8fafc;
        max-height: 360px;
        overflow-y: auto;
        padding: 1rem;
      }

      .log-entry {
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 6px;
        padding: 0.75rem;
        font-size: 0.9rem;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
      }

      .sheet-preview table {
        width: 100%;
        border-collapse: collapse;
        border-radius: 8px;
        overflow: hidden;
        background-color: #fff;
        border: 1px solid #d2d6dc;
      }

      .sheet-preview th,
      .sheet-preview td {
        border: 1px solid #e2e8f0;
        padding: 0.6rem;
        font-size: 0.9rem;
        text-align: left;
      }

      .sheet-preview th {
        background-color: #f1f5f9;
        font-weight: 600;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <main>
      <section class="panel">
        <header>
          <h1>Auto Login</h1>
          <span id="pollingBadge" class="status-badge gray hidden">Idle</span>
        </header>
        <div id="feedback" class="feedback hidden"></div>
      </section>

      <section class="panel">
        <header>
          <h2>Control Panel</h2>
          <span id="runningBadge" class="status-badge blue hidden"
            >Running...</span
          >
        </header>
        <button id="runButton" class="primary">
          <span id="runButtonText">RUN LOGIN</span>
        </button>
        <button id="stopPollingButton" class="secondary hidden">
          Stop Polling
        </button>
      </section>

      <section class="panel">
        <h2>Captcha Image</h2>
        <div class="image-box" id="captchaContainer">
          <span style="color: #6b7280;">No image available.</span>
        </div>
      </section>

      <section class="panel">
        <h2>Enter Captcha</h2>
        <div class="captcha-area">
          <input
            id="captchaInput"
            type="text"
            placeholder="000"
            inputmode="numeric"
            maxlength="3"
            aria-label="Captcha answer (3 digits)"
          />
          <button id="submitButton" class="secondary">Send</button>
        </div>
      </section>

      <section class="panel">
        <header>
          <h2>Log</h2>
          <span id="loadingBadge" class="status-badge gray hidden"
            >Updating...</span
          >
        </header>
        <div id="logsContainer" class="logs">
          <p style="margin: 0; color: #6b7280;">Loading log...</p>
        </div>
      </section>

    </main>

    <script>
      const POLL_INTERVAL_MS = 2000;
      const state = {
        loading: false,
        polling: false,
        running: false,
        pollHandle: null,
        values: [],
        lastRunStatus: '',
      };

      const runButton = document.getElementById('runButton');
      const runButtonText = document.getElementById('runButtonText');
      const stopPollingButton = document.getElementById('stopPollingButton');
      const submitButton = document.getElementById('submitButton');
      const captchaInput = document.getElementById('captchaInput');
      const feedbackEl = document.getElementById('feedback');
      const captchaContainer = document.getElementById('captchaContainer');
      const logsContainer = document.getElementById('logsContainer');
      const sheetTableContainer = document.getElementById(
        'sheetTableContainer'
      );
      const refreshButton = document.getElementById('refreshButton');
      const runningBadge = document.getElementById('runningBadge');
      const pollingBadge = document.getElementById('pollingBadge');
      const loadingBadge = document.getElementById('loadingBadge');

      const FEEDBACK_TYPES = ['success', 'error', 'info'];
      const STATUS_BADGE_VARIANTS = ['gray', 'green', 'blue', 'red'];

      function setFeedback(type, message) {
        feedbackEl.classList.add('hidden');
        FEEDBACK_TYPES.forEach((t) => feedbackEl.classList.remove(t));
        if (!message) {
          return;
        }
        if (type && FEEDBACK_TYPES.includes(type)) {
          feedbackEl.classList.add(type);
        } else {
          feedbackEl.classList.add('info');
        }
        feedbackEl.textContent = message;
        feedbackEl.classList.remove('hidden');
      }

      function clearFeedback() {
        feedbackEl.classList.add('hidden');
        FEEDBACK_TYPES.forEach((t) => feedbackEl.classList.remove(t));
        feedbackEl.textContent = '';
      }

      function updateStatusBadge(label, variant = 'gray') {
        pollingBadge.textContent = label;
        STATUS_BADGE_VARIANTS.forEach((color) => {
          pollingBadge.classList.toggle(color, color === variant);
        });
        pollingBadge.classList.remove('hidden');
      }

      function toggleRunning(isRunning) {
        state.running = isRunning;
        runButton.disabled = isRunning;
        runningBadge.classList.toggle('hidden', !isRunning);
        runButtonText.textContent = isRunning ? 'Sending...' : 'RUN LOGIN';
      }

      function togglePolling(isPolling) {
        state.polling = isPolling;
        if (isPolling) {
          setFeedback('info', 'POLLING...');
          updateStatusBadge('POLLING...', 'blue');
        } else if (!state.lastRunStatus || state.lastRunStatus === 'RUN') {
          clearFeedback();
          updateStatusBadge('IDLE', 'gray');
        }
        stopPollingButton.classList.toggle('hidden', !isPolling);
      }

      function toggleLoading(isLoading) {
        state.loading = isLoading;
        loadingBadge.classList.toggle('hidden', !isLoading);
      }

      function restrictCaptchaInput(value) {
        return value.replace(/\D/g, '').slice(0, 3);
      }

      function getCellValue(values, cellLabel) {
        if (!cellLabel) {
          return '';
        }
        const match = /^([A-Za-z]+)(\d+)$/.exec(cellLabel);
        if (!match) {
          return '';
        }
        const [, letters, rowStr] = match;
        const rowIndex = parseInt(rowStr, 10) - 1;
        if (Number.isNaN(rowIndex) || rowIndex < 0) {
          return '';
        }
        let colIndex = 0;
        for (let i = 0; i < letters.length; i += 1) {
          colIndex *= 26;
          colIndex += letters.toUpperCase().charCodeAt(i) - 64;
        }
        colIndex -= 1;
        if (!values[rowIndex]) {
          return '';
        }
        return values[rowIndex][colIndex] ?? '';
      }

      function resolveImageSource(raw) {
        if (!raw) {
          return null;
        }
        const trimmed = String(raw).trim();
        if (!trimmed) {
          return null;
        }

        const noWhitespace = trimmed.replace(/\s+/g, '');
        const sanitized = noWhitespace.replace(/^["']+|["']+$/g, '');
        if (!sanitized) {
          return null;
        }

        if (
          sanitized.startsWith('http://') ||
          sanitized.startsWith('https://') ||
          sanitized.startsWith('data:')
        ) {
          return sanitized;
        }

        const base64Candidate = sanitized.startsWith('base64,')
          ? sanitized.substring('base64,'.length)
          : sanitized;

        const padding = base64Candidate.length % 4;
        const padded =
          padding === 0
            ? base64Candidate
            : `${base64Candidate}${'='.repeat(4 - padding)}`;

        try {
          if (typeof window !== 'undefined' && typeof window.atob === 'function') {
            window.atob(padded);
          }
          return `data:image/png;base64,${padded}`;
        } catch (error) {
          console.warn('Invalid base64 captcha image', error);
          return null;
        }
      }

      function renderCaptcha(values) {
        let rawImage = getCellValue(values, 'C2');
        let source = resolveImageSource(rawImage);
        if (!source) {
          rawImage = getCellValue(values, 'B2');
          source = resolveImageSource(rawImage);
        }
        captchaContainer.innerHTML = '';
        if (source) {
          const img = document.createElement('img');
          img.src = source;
          img.alt = 'Captcha from Google Sheet';
          captchaContainer.appendChild(img);
        } else {
          const span = document.createElement('span');
          span.style.color = '#6b7280';
          span.textContent = 'No image available.';
          captchaContainer.appendChild(span);
        }
      }

      function renderLogs(values) {
        logsContainer.innerHTML = '';
        const rows = Array.isArray(values) ? values.slice(1) : [];
        const entries = rows
          .map((row, index) => {
            const text = row && row.length > 4 ? String(row[4] ?? '').trim() : '';
            return { row: index + 2, text };
          })
          .filter((entry) => entry.text.length > 0);

        if (!entries.length) {
          const empty = document.createElement('p');
          empty.style.margin = '0';
          empty.style.color = '#6b7280';
          empty.textContent = state.loading
            ? 'Loading log...'
            : 'No log entries yet.';
          logsContainer.appendChild(empty);
          return;
        }

        const fragment = document.createDocumentFragment();
        entries.forEach((entry) => {
          const item = document.createElement('div');
          item.className = 'log-entry';
          item.dataset.row = String(entry.row);
          item.textContent = entry.text;
          fragment.appendChild(item);
        });
        logsContainer.appendChild(fragment);
        logsContainer.scrollTop = logsContainer.scrollHeight;
      }

      function renderTable(values) {
        if (!sheetTableContainer) {
          return;
        }
        sheetTableContainer.innerHTML = '';
        if (!Array.isArray(values) || !values.length) {
          const empty = document.createElement('p');
          empty.style.margin = '0';
          empty.style.color = '#6b7280';
          empty.textContent = 'No data found in this sheet.';
          sheetTableContainer.appendChild(empty);
          return;
        }

        const table = document.createElement('table');
        const tbody = document.createElement('tbody');

        values.forEach((row) => {
          const tr = document.createElement('tr');
          row.forEach((cell) => {
            const td = document.createElement('td');
            td.textContent = cell ?? '';
            tr.appendChild(td);
          });
          if (!row.length) {
            const td = document.createElement('td');
            td.textContent = '';
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        sheetTableContainer.appendChild(table);
      }

      function normalizeStatus(value) {
        if (typeof value === 'string') {
          return value.trim().toUpperCase();
        }
        if (value == null) {
          return '';
        }
        return String(value).trim().toUpperCase();
      }

      function handleRunState(values) {
        const rawStatus = getCellValue(values, 'A2');
        const normalizedStatus = normalizeStatus(rawStatus);
        const statusChanged = normalizedStatus !== state.lastRunStatus;

        if (normalizedStatus === 'RUN') {
          setFeedback('info', 'POLLING...');
          updateStatusBadge('POLLING...', 'blue');
          state.lastRunStatus = normalizedStatus;
          return;
        }

        stopPolling();
        toggleRunning(false);

        if (statusChanged) {
          if (normalizedStatus === 'DONE') {
            setFeedback('success', 'SUCCESS');
            updateStatusBadge('SUCCESS', 'green');
          } else if (normalizedStatus === 'ERROR') {
            setFeedback('error', 'ERROR');
            updateStatusBadge('ERROR', 'red');
          } else if (normalizedStatus) {
            setFeedback('info', normalizedStatus);
            updateStatusBadge(normalizedStatus, 'gray');
          } else {
            clearFeedback();
            updateStatusBadge('IDLE', 'gray');
          }
        }

        state.lastRunStatus = normalizedStatus;
      }

      async function fetchSheetValues() {
        toggleLoading(true);
        try {
          const response = await fetch('/sheet', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'get-state' }),
          });
          if (!response.ok) {
            const body = await response.json().catch(() => ({}));
            throw new Error(body.error || `Request failed (${response.status})`);
          }
          const data = await response.json();
          const values = data.values || data.state?.values || [];
          state.values = values;
          renderCaptcha(values);
          renderLogs(values);
          renderTable(values);
          handleRunState(values);
          return values;
        } finally {
          toggleLoading(false);
        }
      }

      function startPolling() {
        if (state.polling) {
          return;
        }
        togglePolling(true);
        state.pollHandle = setInterval(() => {
          fetchSheetValues().catch((error) => {
            console.error('Failed to poll sheet:', error);
            setFeedback('error', error.message);
            stopPolling();
          });
        }, POLL_INTERVAL_MS);
        fetchSheetValues().catch((error) => {
          console.error('Failed to fetch sheet:', error);
          setFeedback('error', error.message);
          stopPolling();
        });
      }

      function stopPolling() {
        if (state.pollHandle) {
          clearInterval(state.pollHandle);
          state.pollHandle = null;
        }
        togglePolling(false);
      }

      async function updateCell(cell, value) {
        const response = await fetch('/sheet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'update-cell', cell, value }),
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data.error || 'Failed to update cell.');
        }
        return data;
      }

      async function handleRunClick() {
        clearFeedback();
        toggleRunning(true);
      try {
        await updateCell('A2', 'RUN');
        startPolling();
      } catch (error) {
          console.error('RUN LOGIN failed:', error);
          setFeedback('error', error.message || 'RUN LOGIN failed.');
          stopPolling();
        } finally {
          toggleRunning(false);
        }
      }

      let submitting = false;

      function updateSubmitDisabled() {
        submitButton.disabled = submitting || captchaInput.value.length !== 3;
      }

      async function handleSubmitClick() {
        const trimmed = captchaInput.value.trim();
        if (trimmed.length !== 3) {
          setFeedback('error', 'Please enter exactly 3 digits before sending.');
          return;
        }

        submitting = true;
        updateSubmitDisabled();
        clearFeedback();
        try {
          await updateCell('D2', trimmed);
          setFeedback('success', 'Captcha code saved to cell D2.');
          captchaInput.value = '';
          await fetchSheetValues();
        } catch (error) {
          console.error('Submit captcha failed:', error);
          setFeedback('error', error.message || 'Failed to submit captcha.');
        } finally {
          submitting = false;
          updateSubmitDisabled();
        }
      }

      function handleStopPollingClick() {
        stopPolling();
        setFeedback('info', 'Polling stopped. Click RUN LOGIN to resume.');
      }

      runButton.addEventListener('click', handleRunClick);
      submitButton.addEventListener('click', handleSubmitClick);
      stopPollingButton.addEventListener('click', handleStopPollingClick);
      if (refreshButton) {
        refreshButton.addEventListener('click', () => {
          fetchSheetValues().catch((error) => {
            console.error('Refresh failed:', error);
            setFeedback('error', error.message);
          });
        });
      }

      captchaInput.addEventListener('input', (event) => {
        const digitsOnly = restrictCaptchaInput(event.target.value);
        event.target.value = digitsOnly;
        updateSubmitDisabled();
      });

      window.addEventListener('focus', () => {
        if (state.polling) {
          fetchSheetValues().catch((error) => {
            console.error('Refresh on focus failed:', error);
          });
        }
      });

      window.addEventListener('beforeunload', () => {
        stopPolling();
      });

      // Initial load
      updateSubmitDisabled();
      fetchSheetValues().catch((error) => {
        console.error('Initial fetch failed:', error);
        setFeedback('error', error.message);
      });
    </script>
  </body>
</html>

